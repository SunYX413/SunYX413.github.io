<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Css学习笔记</title>
    <url>/2020/03/23/Css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Css学习笔记"><a href="#Css学习笔记" class="headerlink" title="Css学习笔记"></a><center>Css学习笔记</center></h1><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p> Cascading Style Sheets 层叠样式表</p>
<ul>
<li>多个样式可以作用在同一个html的元素上，同时生效</li>
</ul>
<h3 id="二、优点"><a href="#二、优点" class="headerlink" title="二、优点"></a>二、优点</h3><ol>
<li>功能强大。</li>
<li>将内容展示和样式控制分离。<ul>
<li>降低耦合度。解耦</li>
<li>让分工协作更容易</li>
<li>提高开发效率</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h3 id="三、Css的使用"><a href="#三、Css的使用" class="headerlink" title="三、Css的使用"></a>三、Css的使用</h3><p>1.<strong>内联样式</strong>      </p>
<ul>
<li>在标签内使用style属性指定css代码</li>
<li>如：<code>&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;</code></li>
</ul>
<p>2.<strong>内部样式</strong></p>
<ul>
<li><p>在标签内使用style属性指定css代码</p>
</li>
<li><p>如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      	div&#123;</span><br><span class="line"><span class="css">      	 <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">      	&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>3.<strong>外部样式</strong></p>
<p>1.定义css资源文件。</p>
<p>2.在head标签内，定义link标签，引入外部的资源文件</p>
<ul>
<li><p>如：a.css文件：div{color:green;}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;a.css&quot;&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><code>3种格式可以写为：&lt;style&gt; @import &quot;css/a.css；&lt;/style&gt;</code></p>
<p>4.<strong>Css语法</strong></p>
<ul>
<li><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">	属性名1:属性值1;</span><br><span class="line">	属性名2:属性值2;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择器:筛选具有相似特征的元素。</p>
</li>
<li><p><strong>注意</strong>：每一对属性需要使用；隔开，最后一对属性可以不加；</p>
</li>
</ul>
<p>5.<strong>选择器</strong></p>
<ul>
<li>分类：<ol>
<li>基础选择器<ul>
<li>id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一。</li>
<li>语法：#id属性值{}</li>
</ul>
</li>
<li>元素选择器：选择具有相同标签名称的元素<ul>
<li>语法： 标签名称{}</li>
<li><strong>注意</strong>：id选择器优先级高于元素选择器**。</li>
</ul>
</li>
<li>类选择器：选择具有相同的class属性值的元素。<ul>
<li>语法：.class属性值{}</li>
<li><strong>注意</strong>：类选择器选择器优先级高于元素选择器。**</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>扩展选择器</strong>：</p>
<ol>
<li><p>选择所有元素：</p>
<ul>
<li>语法： *{}</li>
</ul>
</li>
<li><p>并集选择器：</p>
<ul>
<li>选择器1,选择器2{}</li>
</ul>
</li>
<li><p>子选择器：筛选选择器1元素下的选择器2元素</p>
<ul>
<li>语法：  选择器1 选择器2{}</li>
</ul>
</li>
<li><p>父选择器：筛选选择器2的父元素选择器1</p>
<ul>
<li>语法：  选择器1 &gt; 选择器2{}</li>
</ul>
</li>
<li><p>属性选择器：选择元素名称，属性名=属性值的元素</p>
<ul>
<li>语法：  元素名称[属性名=”属性值”]{}</li>
</ul>
</li>
<li><p>伪类选择器：选择一些元素具有的状态</p>
<ul>
<li><p>语法： 元素:状态{}</p>
</li>
<li><p>如：<code>&lt;a&gt;</code></p>
<ul>
<li><p>状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link：初始化的状态</span><br><span class="line">visited：被访问过的状态</span><br><span class="line">active：正在访问状态</span><br><span class="line">hover：鼠标悬浮状态</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>6.<strong>CSS常用属性</strong></p>
<p>1.字体、文本</p>
<ul>
<li>font-size:字体大小</li>
<li>color：文本颜色</li>
<li>text-align：对其方式</li>
<li>line-height：行高 </li>
</ul>
<p>2.背景</p>
<ul>
<li><p>background：</p>
</li>
<li><p>语法：background: <em>color position size repeat origin clip attachment  image</em>;</p>
</li>
<li><p>例如：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">background: #00ff00 url('smiley.gif') no-repeat fixed center</span><br></pre></td></tr></table></figure>





</li>
</ul>
<p>3.边框</p>
<ul>
<li><p>border:border-width, border-style,border-color</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">border:1px solider red</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>4.尺寸</p>
<ul>
<li>width：宽度</li>
<li>height：高度</li>
</ul>
<p>5.盒子模型</p>
<ul>
<li>margin：外边距</li>
<li>padding：内边距<ul>
<li>默认情况下内边距会影响整个盒子的大小</li>
<li>box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小</li>
</ul>
</li>
<li>float：浮动<ul>
<li>left: 左浮动</li>
<li>right:右浮动</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法</title>
    <url>/2020/03/21/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="MarkDown语法"><a href="#MarkDown语法" class="headerlink" title="MarkDown语法"></a><center>MarkDown语法<center></h2><p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>相比WYSIWYG编辑器</p>
<p><strong>优点：</strong></p>
<p>1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br> 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</p>
<p><strong>缺点：</strong></p>
<p>1、需要记一些语法（当然，是很简单。五分钟学会）。</p>
<p>2、有些平台不支持Markdown编辑模式。</p>
<a id="more"></a>

<p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一级标题</span></span><br><span class="line"><span class="comment">## 这是二级标题</span></span><br><span class="line"><span class="comment">### 这是三级标题</span></span><br><span class="line"><span class="comment">#### 这是四级标题</span></span><br><span class="line"><span class="comment">##### 这是五级标题</span></span><br><span class="line"><span class="comment">###### 这是六级标题</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><ul>
<li><strong>加粗</strong></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><p><em>斜体</em></p>
</li>
<li><p>要倾斜的文字左右分别用一个*号包起来</p>
</li>
</ul>
<p><strong><em>斜体加粗</em></strong></p>
<ul>
<li>要倾斜和加粗的文字左右分别用三个*号包起来</li>
</ul>
<p><del>删除线</del></p>
<ul>
<li>要加删除线的文字左右分别用两个~~号包起来</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p>
<h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…</p>
<p>貌似可以一直加下去，但没神马卵用</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">****</span><br></pre></td></tr></table></figure>

<p>效果如下：<br>可以看到，显示效果是一样的。</p>
<hr>
<hr>
<hr>
<h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 <span class="string">''</span>图片title<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/" class="lazyload" data-src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2436786008,3765340035&fm=11&gp=0.jpg"  alt="图片" title="王者荣耀"></p>
<p><strong>上传本地图片直接点击导航栏的图片标志，选择图片即可</strong></p>
<p>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。<br> 关于图床的选择我写了一篇文章，对网上存在的各种方法做了总结，需要的朋友可以看看。</p>
<h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><p>语法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 <span class="string">"超链接title"</span>)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a></p>
<p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
<p>注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"超链接地址"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>超链接名<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.jianshu.com/u/1f5ac0cf6a8b"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>简书<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>语法：</p>
<p>序列表用 - + * 任何一种都可以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<p>效果如下:</p>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>语法：<br>数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h5 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h5><p><strong>上一级和下一级之间敲三个空格即可</strong></p>
<ul>
<li><p>一级无序列表内容</p>
<ul>
<li>二级无序列表内容</li>
</ul>
<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li><p>一级无序列表内容</p>
<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容 </li>
</ol>
</li>
</ul>
<ol>
<li>一级无序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级有序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ol>
<h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`代码内容`</span></span><br></pre></td></tr></table></figure>

<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(<span class="string">``</span><span class="string">`)</span></span><br><span class="line"><span class="string">  代码...</span></span><br><span class="line"><span class="string">  代码...</span></span><br><span class="line"><span class="string">  代码...</span></span><br><span class="line"><span class="string">(`</span><span class="string">``</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
</blockquote>
<p>示例：</p>
<p>单行代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`create database ddd;`</span></span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">         <span class="built_in">echo</span> <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>单行代码</p>
<p><code>create database ddd</code>;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<h1 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">​```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;``</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>网页有可能不支持流程图，所以我把图片截取下来了</p>
<p><img src="/" class="lazyload" data-src="/img/liucheng.jpg"  alt="流程图" title="流程图"></p>
<p>以上就i是MarkDown的基本语法，这些应该足够我们用了， MarkDown用起来也很方便！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>MarkDown语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记（二）</title>
    <url>/2020/03/28/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Mybatis学习笔记（二）"><a href="#Mybatis学习笔记（二）" class="headerlink" title="Mybatis学习笔记（二）"></a><center>Mybatis学习笔记（二）</center></h1><h3 id="1-根据ID查询"><a href="#1-根据ID查询" class="headerlink" title="1.根据ID查询"></a>1.根据ID查询</h3><h4 id="1-1在持久层接口中添加-findById-方法"><a href="#1-1在持久层接口中添加-findById-方法" class="headerlink" title="1.1在持久层接口中添加 findById 方法"></a>1.1在持久层接口中添加 findById 方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据Id查询</span><br><span class="line"> *&#x2F;</span><br><span class="line">User findById(int userId);</span><br></pre></td></tr></table></figure>

<h4 id="1-2在用户的映射配置文件中配置"><a href="#1-2在用户的映射配置文件中配置" class="headerlink" title="1.2在用户的映射配置文件中配置"></a>1.2在用户的映射配置文件中配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据Id查询--&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findById&quot; resultType&#x3D;&quot;com.syx.domain.User&quot; parameterType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">    select * from user  where id &#x3D; #&#123;uid&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<p>细节：<br><strong>resultType 属性</strong>：用于指定结果集的类型。<br><strong>parameterType 属性</strong>：  用于指定传入参数的类型。<br><strong>sql 语句中使用#{}字符</strong>：它代表占位符， 相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。具体的数据是由#{}里面的内容决定的。<br> <strong>#{}中内容的写法</strong>：由于数据类型是基本类型，所以此处可以随意写。  </p>
<a id="more"></a>

<h4 id="1-3-在测试类添加测试"><a href="#1-3-在测试类添加测试" class="headerlink" title="1.3 在测试类添加测试"></a>1.3 在测试类添加测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MybatisTest &#123;</span><br><span class="line">    private InputStream in ;</span><br><span class="line">    private SqlSessionFactory factory;</span><br><span class="line">    private SqlSession session;</span><br><span class="line">    private IUserDao userDao;</span><br><span class="line">    @Before</span><br><span class="line">    public void init() throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1.读取配置文件</span><br><span class="line">       in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.创建构建者对象</span><br><span class="line">        SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">        &#x2F;&#x2F; 3.创建SqlSession工厂对象</span><br><span class="line">         factory &#x3D; builder.build(in);</span><br><span class="line">        &#x2F;&#x2F;4.创建SqlSession对向</span><br><span class="line">        session &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;5.创建Dao代理对象</span><br><span class="line">        userDao &#x3D; session.getMapper(IUserDao.class);</span><br><span class="line">        &#125;</span><br><span class="line">        @After</span><br><span class="line">        public void destroy() throws Exception&#123;</span><br><span class="line">            session.commit();</span><br><span class="line">            &#x2F;&#x2F;7.释放资源</span><br><span class="line">            session.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void findById()&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;6.执行操作</span><br><span class="line">        User user &#x3D; userDao.findById(41);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-保存操作"><a href="#2-保存操作" class="headerlink" title="2.保存操作"></a>2.保存操作</h3><h4 id="2-1在持久层接口中新增方法"><a href="#2-1在持久层接口中新增方法" class="headerlink" title="2.1在持久层接口中新增方法"></a>2.1在持久层接口中新增方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *保存用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">int saveUser(User user);</span><br></pre></td></tr></table></figure>

<h4 id="2-2在用户的映射配置文件中配置"><a href="#2-2在用户的映射配置文件中配置" class="headerlink" title="2.2在用户的映射配置文件中配置"></a>2.2在用户的映射配置文件中配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 保存用户--&gt;</span><br><span class="line">&lt;insert id&#x3D;&quot;saveUser&quot; parameterType&#x3D;&quot;com.syx.domain.User&quot;&gt;</span><br><span class="line">    insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>

<p>细节：<br>parameterType 属性：代表参数的类型，因为我们要传入的是一个类的对象，所以类型就写类的全名称。<br>sql 语句中使用#{}字符：它代表占位符， 相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。具体的数据是由#{}里面的内容决定的。<br>#{}中内容的写法：由于我们保存方法的参数是 一个 User 对象，此处要写 User 对象中的属性名称。它用的是 ognl 表达式。<br>ognl 表达式：<br>它是 apache 提供的一种表达式语言， 全称是Object Graphic Navigation Language 对象图导航语言它是按照一定的语法格式来获取数据的。语法格式就是使用 #{对象.对象}的方式</p>
<p>#{user.username}它会先去找 user 对象，然后在 user 对象中找到 username 属性，并调用getUsername()方法把值取出来。但是我们在 parameterType 属性上指定了实体类名称，所以可以省略 user.而直接写 username。  </p>
<h4 id="2-3测试方法"><a href="#2-3测试方法" class="headerlink" title="2.3测试方法"></a>2.3测试方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void saveUser()&#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setUsername(&quot;Mybatis save&quot;);</span><br><span class="line">        user.setSex(&quot;男&quot;);</span><br><span class="line">        user.setAddress(&quot;河南&quot;);</span><br><span class="line">        user.setBirthday(new Date());</span><br><span class="line">        int i &#x3D; userDao.saveUser(user);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4问题扩展：新增用户-id-的返回值"><a href="#2-4问题扩展：新增用户-id-的返回值" class="headerlink" title="2.4问题扩展：新增用户 id 的返回值"></a>2.4问题扩展：新增用户 id 的返回值</h4><p>新增用户后， 同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长 auto_increment 的值返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 保存用户--&gt;</span><br><span class="line">&lt;insert id&#x3D;&quot;saveUser&quot; parameterType&#x3D;&quot;com.syx.domain.User&quot;&gt;</span><br><span class="line">    &lt;!-- 配置保存时获取插入的 id --&gt;</span><br><span class="line">    &lt;selectKey keyColumn&#x3D;&quot;id&quot; keyProperty&#x3D;&quot;id&quot; resultType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">        select last_insert_id();</span><br><span class="line">    &lt;&#x2F;selectKey&gt;</span><br><span class="line">    insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-用户更新"><a href="#3-用户更新" class="headerlink" title="3.用户更新"></a>3.用户更新</h3><h4 id="3-1在持久层接口中添加更新方法"><a href="#3-1在持久层接口中添加更新方法" class="headerlink" title="3.1在持久层接口中添加更新方法"></a>3.1在持久层接口中添加更新方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 更新用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">int updateUser(User user);</span><br></pre></td></tr></table></figure>

<h4 id="3-2在用户的映射配置文件中配置"><a href="#3-2在用户的映射配置文件中配置" class="headerlink" title="3.2在用户的映射配置文件中配置"></a>3.2在用户的映射配置文件中配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 更新用户--&gt;</span><br><span class="line">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;com.syx.domain.User&quot;&gt;</span><br><span class="line">    update user set username&#x3D;#&#123;username&#125;,birthday&#x3D;#&#123;birthday&#125;,sex&#x3D;#&#123;sex&#125;,address&#x3D;#&#123;address&#125; where id&#x3D;#&#123;id&#125;</span><br><span class="line">&lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-3加入更新的测试方法"><a href="#3-3加入更新的测试方法" class="headerlink" title="3.3加入更新的测试方法"></a>3.3加入更新的测试方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">  public void updateUser()&#123;</span><br><span class="line">      User user &#x3D; new User();</span><br><span class="line">      user.setId(51);</span><br><span class="line">      user.setUsername(&quot;Mybatis update&quot;);</span><br><span class="line">      user.setSex(&quot;男&quot;);</span><br><span class="line">      user.setAddress(&quot;河南&quot;);</span><br><span class="line">      user.setBirthday(new Date());</span><br><span class="line">      userDao.updateUser(user);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-用户删除"><a href="#4-用户删除" class="headerlink" title="4.用户删除"></a>4.用户删除</h3><h4 id="4-1在持久层接口中添加删除方法"><a href="#4-1在持久层接口中添加删除方法" class="headerlink" title="4.1在持久层接口中添加删除方法"></a>4.1在持久层接口中添加删除方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">int deleteUser(Integer userId);</span><br></pre></td></tr></table></figure>

<h4 id="4-2在用户的映射配置文件中配置"><a href="#4-2在用户的映射配置文件中配置" class="headerlink" title="4.2在用户的映射配置文件中配置"></a>4.2在用户的映射配置文件中配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 删除用户--&gt;</span><br><span class="line">&lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;Integer&quot;&gt;</span><br><span class="line">    delete from user where id &#x3D; #&#123;uid&#125;</span><br><span class="line">&lt;&#x2F;delete&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-3加入删除的测试方法"><a href="#4-3加入删除的测试方法" class="headerlink" title="4.3加入删除的测试方法"></a>4.3加入删除的测试方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void deleteUser()&#123;</span><br><span class="line">    userDao.deleteUser(51);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-用户模糊查询"><a href="#5-用户模糊查询" class="headerlink" title="5.用户模糊查询"></a>5.用户模糊查询</h3><h4 id="5-1在持久层接口中添加模糊查询方法"><a href="#5-1在持久层接口中添加模糊查询方法" class="headerlink" title="5.1在持久层接口中添加模糊查询方法"></a>5.1在持久层接口中添加模糊查询方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据名字模糊查询</span><br><span class="line"> *&#x2F;</span><br><span class="line">List&lt;User&gt; findByName(String username);</span><br></pre></td></tr></table></figure>

<h4 id="5-2在用户的映射配置文件中配置"><a href="#5-2在用户的映射配置文件中配置" class="headerlink" title="5.2在用户的映射配置文件中配置"></a>5.2在用户的映射配置文件中配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据名字模糊查询--&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findByName&quot; resultType&#x3D;&quot;com.syx.domain.User&quot; parameterType&#x3D;&quot;String&quot;&gt;</span><br><span class="line">    select * from user where username like #&#123;username&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-3测试方法"><a href="#5-3测试方法" class="headerlink" title="5.3测试方法"></a>5.3测试方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void findByName()&#123;</span><br><span class="line">    List&lt;User&gt; userList &#x3D; userDao.findByName(&quot;%王%&quot;);</span><br><span class="line">    for (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-查询使用聚合函数"><a href="#6-查询使用聚合函数" class="headerlink" title="6.查询使用聚合函数"></a>6.查询使用聚合函数</h4><h4 id="6-1在持久层接口中添加模糊查询方法"><a href="#6-1在持久层接口中添加模糊查询方法" class="headerlink" title="6.1在持久层接口中添加模糊查询方法"></a>6.1在持久层接口中添加模糊查询方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查询总记录数</span><br><span class="line"> *&#x2F;</span><br><span class="line">int findTotal();</span><br></pre></td></tr></table></figure>

<h4 id="6-2在用户的映射配置文件中配置"><a href="#6-2在用户的映射配置文件中配置" class="headerlink" title="6.2在用户的映射配置文件中配置"></a>6.2在用户的映射配置文件中配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--查询总记录条数 --&gt;</span><br><span class="line"> &lt;select id&#x3D;&quot;findTotal&quot; resultType&#x3D;&quot;Integer&quot;&gt;</span><br><span class="line">     select count(*) from user</span><br><span class="line"> &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h4 id="6-3加入聚合查询的测试方法"><a href="#6-3加入聚合查询的测试方法" class="headerlink" title="6.3加入聚合查询的测试方法"></a>6.3加入聚合查询的测试方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public  void findTotal()&#123;</span><br><span class="line">    int total &#x3D; userDao.findTotal();</span><br><span class="line">    System.out.println(total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记（三）</title>
    <url>/2020/03/28/Mybatie%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Mybatis学习笔记（三）"><a href="#Mybatis学习笔记（三）" class="headerlink" title="Mybatis学习笔记（三）"></a><center>Mybatis学习笔记（三）</center></h1><h2 id="1-Mybatis-的输出结果封装"><a href="#1-Mybatis-的输出结果封装" class="headerlink" title="1.Mybatis 的输出结果封装"></a>1.Mybatis 的输出结果封装</h2><h4 id="1-1resultMap-结果类型"><a href="#1-1resultMap-结果类型" class="headerlink" title="1.1resultMap 结果类型"></a>1.1resultMap 结果类型</h4><blockquote>
<p>resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。<br>在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类<br>型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。  </p>
</blockquote>
<a id="more"></a>

<h4 id="1-2定义-resultMap"><a href="#1-2定义-resultMap" class="headerlink" title="1.2定义 resultMap"></a>1.2定义 resultMap</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 建立 User 实体和数据库表的对应关系type </span><br><span class="line">属性：指定实体类的全限定类名</span><br><span class="line">id 属性：给定一个唯一标识，是给查询 select 标签引用用的。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;resultMap type&#x3D;&quot;com.itheima.domain.User&quot; id&#x3D;&quot;userMap&quot;&gt;</span><br><span class="line">&lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;userId&quot;&#x2F;&gt;</span><br><span class="line">&lt;result column&#x3D;&quot;username&quot; property&#x3D;&quot;userName&quot;&#x2F;&gt;</span><br><span class="line">&lt;result column&#x3D;&quot;sex&quot; property&#x3D;&quot;userSex&quot;&#x2F;&gt;</span><br><span class="line">&lt;result column&#x3D;&quot;address&quot; property&#x3D;&quot;userAddress&quot;&#x2F;&gt;</span><br><span class="line">&lt;result column&#x3D;&quot;birthday&quot; property&#x3D;&quot;userBirthday&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>id 标签：用于指定主键字段<br>result 标签：用于指定非主键字段<br>column 属性：用于指定数据库列名<br>property 属性：用于指定实体类属性名称  </p>
</blockquote>
<h4 id="1-3映射配置"><a href="#1-3映射配置" class="headerlink" title="1.3映射配置"></a>1.3映射配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置查询所有操作 --&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;userMap&quot;&gt;</span><br><span class="line">select * from user</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-SqlMapConfig-xml配置文件"><a href="#2-SqlMapConfig-xml配置文件" class="headerlink" title="2.SqlMapConfig.xml配置文件"></a>2.SqlMapConfig.xml配置文件</h2><h4 id="2-1-SqlMapConfig-xml-中配置的内容和顺序"><a href="#2-1-SqlMapConfig-xml-中配置的内容和顺序" class="headerlink" title="2.1.SqlMapConfig.xml 中配置的内容和顺序"></a>2.1.SqlMapConfig.xml 中配置的内容和顺序</h4><blockquote>
<p>-properties（属性）<br>—property<br>-settings（全局配置参数）<br>—setting<br>-typeAliases（类型别名）<br>—typeAliase<br>—package<br>-typeHandlers（类型处理器）<br>-objectFactory（对象工厂）<br>-plugins（插件）<br>-environments（环境集合属性对象）<br>—environment（环境子属性对象）<br>  —–transactionManager（事务管理）<br>  —–dataSource（数据源）<br>-mappers（映射器）<br>—mapper<br>                                                                —package  </p>
</blockquote>
<h4 id="2-2properties（属性）"><a href="#2-2properties（属性）" class="headerlink" title="2.2properties（属性）"></a>2.2properties（属性）</h4><blockquote>
<p>在使用 properties 标签配置时，我们可以采用两种方式指定属性配置。  </p>
</blockquote>
<h5 id="2-2-1第一种"><a href="#2-2-1第一种" class="headerlink" title="2.2.1第一种"></a>2.2.1第一种</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;jdbc.driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;jdbc.url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;jdbc.username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;jdbc.password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2第二种"><a href="#2-2-2第二种" class="headerlink" title="2.2.2第二种"></a>2.2.2第二种</h5><ul>
<li><p>*<em>在 classpath 下定义 db.properties 文件  *</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis</span><br><span class="line">jdbc.username&#x3D;root</span><br><span class="line">jdbc.password&#x3D;root</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>properties 标签配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置连接数据库的信息</span><br><span class="line">resource 属性：用于指定 properties 配置文件的位置，要求配置文件必须在类路径下</span><br><span class="line">resource&#x3D;&quot;jdbcConfig.properties&quot;</span><br><span class="line">url 属性：</span><br><span class="line">URL： Uniform Resource Locator 统一资源定位符</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;mystroe&#x2F;CategoryServlet URL</span><br><span class="line">协议 主机 端口 URI</span><br><span class="line">URI： Uniform Resource Identifier 统一资源标识符</span><br><span class="line">&#x2F;mystroe&#x2F;CategoryServlet</span><br><span class="line">它是可以在 web 应用中唯一定位一个资源的路径</span><br><span class="line">--&gt;</span><br><span class="line">&lt;properties url&#x3D;</span><br><span class="line">file:&#x2F;&#x2F;&#x2F;D:&#x2F;IdeaProjects&#x2F;day02_eesy_01mybatisCRUD&#x2F;src&#x2F;main&#x2F;resources&#x2F;jdbcConfig.prop</span><br><span class="line">erties&quot;&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>*<em>此时我们的 dataSource 标签就变成了引用上面的配置  *</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dataSource&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-3typeAliases（类型别名）"><a href="#2-3typeAliases（类型别名）" class="headerlink" title="2.3typeAliases（类型别名）"></a>2.3typeAliases（类型别名）</h4><blockquote>
<p>在前面我们讲的 Mybatis 支持的默认别名，我们也可以采用自定义别名方式来开发。  </p>
</blockquote>
<h5 id="2-3-1自定义别名："><a href="#2-3-1自定义别名：" class="headerlink" title="2.3.1自定义别名："></a>2.3.1自定义别名：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 SqlMapConfig.xml 中配置：</span><br><span class="line">&lt;typeAliases&gt;</span><br><span class="line">&lt;!-- 单个别名定义 --&gt;</span><br><span class="line">&lt;typeAlias alias&#x3D;&quot;user&quot; type&#x3D;&quot;com.itheima.domain.User&quot;&#x2F;&gt;</span><br><span class="line">&lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt;</span><br><span class="line">&lt;package name&#x3D;&quot;com.itheima.domain&quot;&#x2F;&gt;</span><br><span class="line">&lt;package name&#x3D;&quot;其它包&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;typeAliases&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-4mappers（映射器）"><a href="#2-4mappers（映射器）" class="headerlink" title="2.4mappers（映射器）"></a>2.4mappers（映射器）</h4><p><code>1.&lt;mapper resource=&quot; &quot; /&gt;</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用相对于类路径的资源</span><br><span class="line">如： &lt;mapper resource&#x3D;&quot;com&#x2F;itheima&#x2F;dao&#x2F;IUserDao.xml&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><code>2.&lt;mapper class=&quot; &quot; /&gt;</code>  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 mapper 接口类路径</span><br><span class="line">如： &lt;mapper class&#x3D;&quot;com.itheima.dao.UserDao&quot;&#x2F;&gt;</span><br><span class="line">注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。</span><br></pre></td></tr></table></figure>

<p><code>3.&lt;package name=&quot;&quot;/&gt;</code>  </p>
<figure class="highlight plain"><figcaption><span>mapper 接口</span></figcaption><table><tr><td class="code"><pre><span class="line">如： &lt;package name&#x3D;&quot;cn.itcast.mybatis.mapper&quot;&#x2F;&gt;</span><br><span class="line">注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记（一）</title>
    <url>/2020/03/27/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="MyBatis学习笔记（一）"><a href="#MyBatis学习笔记（一）" class="headerlink" title="MyBatis学习笔记（一）"></a><center>MyBatis学习笔记（一）</center></h1><h3 id="1-Mybatis概述"><a href="#1-Mybatis概述" class="headerlink" title="1.Mybatis概述"></a>1.Mybatis概述</h3><p>mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。</p>
<p>mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。</p>
<p>采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。  </p>
<a id="more"></a>

<h3 id="2-Mybatis环境搭建"><a href="#2-Mybatis环境搭建" class="headerlink" title="2.Mybatis环境搭建"></a>2.Mybatis环境搭建</h3><h4 id="2-1创建maven工程"><a href="#2-1创建maven工程" class="headerlink" title="2.1创建maven工程"></a>2.1创建maven工程</h4><p>创建 mybatis01 的工程，工程信息如下：<br>Groupid:com.syx<br>ArtifactId:mybatis<br>Packing:jar  </p>
<h4 id="2-2添加Mybatis坐标"><a href="#2-2添加Mybatis坐标" class="headerlink" title="2.2添加Mybatis坐标"></a>2.2添加Mybatis坐标</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.6&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.6&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-3编写User实体类"><a href="#2-3编写User实体类" class="headerlink" title="2.3编写User实体类"></a>2.3编写User实体类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private  Integer id;</span><br><span class="line">    private  String username;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private  String sex;</span><br><span class="line">    private  String address;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday &#x3D; birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, birthday&#x3D;&quot; + birthday +</span><br><span class="line">                &quot;, sex&#x3D;&#39;&quot; + sex + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, address&#x3D;&#39;&quot; + address + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4编写持久层接口IUserDao"><a href="#2-4编写持久层接口IUserDao" class="headerlink" title="2.4编写持久层接口IUserDao"></a>2.4编写持久层接口IUserDao</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 用户持久层接口</span><br><span class="line">* *&#x2F;</span><br><span class="line">public interface IUserDao &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询所有方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5编写持久层接口映射文件IUserDao-xml"><a href="#2-5编写持久层接口映射文件IUserDao-xml" class="headerlink" title="2.5编写持久层接口映射文件IUserDao.xml"></a>2.5编写持久层接口映射文件IUserDao.xml</h4><p>要求：</p>
<ul>
<li>创建位置： 必须和持久层接口在相同的包中。</li>
<li>名称： 必须以持久层接口名称命名文件名，扩展名是.xml  </li>
</ul>
<p><img src="/" class="lazyload" data-src="/img/Mybatis/1.png"  alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"> &lt;mapper namespace&#x3D;&quot;com.syx.dao.IUserDao&quot;&gt;</span><br><span class="line">    &lt;!-- 配置查询所有--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;com.syx.domain.User&quot;&gt;</span><br><span class="line">        select  * from user</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-6编写SqlMapConfig-xml-主配置文件"><a href="#2-6编写SqlMapConfig-xml-主配置文件" class="headerlink" title="2.6编写SqlMapConfig.xml 主配置文件"></a>2.6编写SqlMapConfig.xml 主配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--配置环境 --&gt;</span><br><span class="line">    &lt;environments default&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">        &lt;!-- 配置mysql环境--&gt;</span><br><span class="line">        &lt;environment id&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">            &lt;!-- 配置事务类型--&gt;</span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;</span><br><span class="line">            &lt;!--配置数据源(连接池) --&gt;</span><br><span class="line">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;dataSource&gt;</span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line">    &lt;&#x2F;environments&gt;</span><br><span class="line">    &lt;!--指定映射配置文件位置，映射配置文件指的是每个dao独立配置的文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource&#x3D;&quot;com&#x2F;syx&#x2F;dao&#x2F;IUserDao.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-7编写测试类"><a href="#2-7编写测试类" class="headerlink" title="2.7编写测试类"></a>2.7编写测试类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MybatisTest &#123;</span><br><span class="line">    public static void main(String[] args) throws   Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;1.读取配置文件</span><br><span class="line">        InputStream in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.创建SqlSessionFactory工厂</span><br><span class="line">        SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory &#x3D; builder.build(in);</span><br><span class="line">        &#x2F;&#x2F;3.试用工厂创建SqlSession对象</span><br><span class="line">        SqlSession sqlSession &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;4.使用SqlSession创建Dao接口的代理对象</span><br><span class="line">        IUserDao dao &#x3D; sqlSession.getMapper(IUserDao.class);</span><br><span class="line">        &#x2F;&#x2F;5.使用代理对象执行方法</span><br><span class="line">        List&lt;User&gt; userList &#x3D; dao.findAll();</span><br><span class="line">        for (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;6.释放资源</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-8数据库搭建"><a href="#2-8数据库搭建" class="headerlink" title="2.8数据库搭建"></a>2.8数据库搭建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;user&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL auto_increment,</span><br><span class="line">  &#96;username&#96; varchar(32) NOT NULL COMMENT &#39;用户名称&#39;,</span><br><span class="line">  &#96;birthday&#96; datetime default NULL COMMENT &#39;生日&#39;,</span><br><span class="line">  &#96;sex&#96; char(1) default NULL COMMENT &#39;性别&#39;,</span><br><span class="line">  &#96;address&#96; varchar(256) default NULL COMMENT &#39;地址&#39;,</span><br><span class="line">  PRIMARY KEY  (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">insert  into &#96;user&#96;(&#96;id&#96;,&#96;username&#96;,&#96;birthday&#96;,&#96;sex&#96;,&#96;address&#96;) values (41,&#39;老王&#39;,&#39;2018-02-27 17:47:08&#39;,&#39;男&#39;,&#39;北京&#39;),(42,&#39;小二王&#39;,&#39;2018-03-02 15:09:37&#39;,&#39;女&#39;,&#39;北京金燕龙&#39;),(43,&#39;小二王&#39;,&#39;2018-03-04 11:34:34&#39;,&#39;女&#39;,&#39;北京金燕龙&#39;),(45,&#39;a&#39;,&#39;2018-03-04 12:04:06&#39;,&#39;男&#39;,&#39;北京金燕龙&#39;),(46,&#39;老王&#39;,&#39;2018-03-07 17:37:26&#39;,&#39;男&#39;,&#39;北京&#39;),(48,&#39;小马宝莉&#39;,&#39;2018-03-08 11:44:00&#39;,&#39;女&#39;,&#39;北京修正&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="2-9补充（基于注解的-mybatis-使用）"><a href="#2-9补充（基于注解的-mybatis-使用）" class="headerlink" title="2.9补充（基于注解的 mybatis 使用）"></a>2.9补充（基于注解的 mybatis 使用）</h4><h5 id="2-9-1在持久层接口中添加注解"><a href="#2-9-1在持久层接口中添加注解" class="headerlink" title="2.9.1在持久层接口中添加注解"></a>2.9.1在持久层接口中添加注解</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 用户持久层接口</span><br><span class="line">* *&#x2F;</span><br><span class="line">public interface IUserDao &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询所有方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Select(&quot;select * from user&quot;)</span><br><span class="line">    List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-9-2修改-SqlMapConfig-xml"><a href="#2-9-2修改-SqlMapConfig-xml" class="headerlink" title="2.9.2修改 SqlMapConfig.xml"></a>2.9.2修改 SqlMapConfig.xml</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--指定映射配置文件位置，映射配置文件指的是每个dao独立配置的文件--&gt;</span><br><span class="line">   &lt;mappers&gt;</span><br><span class="line">       &lt;mapper class&#x3D;&quot;com.syx.dao.IUserDao&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mappers&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-9-3注意事项"><a href="#2-9-3注意事项" class="headerlink" title="2.9.3注意事项"></a>2.9.3注意事项</h5><blockquote>
<p>在使用基于注解的 Mybatis 配置时，请移除 xml 的映射配置（IUserDao.xml）。<br>补充  </p>
</blockquote>
]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax使用</title>
    <url>/2020/03/22/ajax%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="ajax使用"><a href="#ajax使用" class="headerlink" title="ajax使用"></a><center>ajax使用</center></h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>1.概念： ASynchronous JavaScript And XML    异步的JavaScript 和 XML</p>
<p>异步和同步：客户端和服务器端相互通信的基础上</p>
<ul>
<li>客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。</li>
<li>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。<br>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</li>
<li>提升用户的体验</li>
</ul>
<a id="more"></a>

<p><img src="/" class="lazyload" data-src="/img/ajax.bmp"  alt="效果图"></p>
<h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><ul>
<li><p>原生js实现：(太过于麻烦，很少有人使用)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//1.创建核心对象</span><br><span class="line">var xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (window.XMLHttpRequest)</span><br><span class="line">&#123;// code <span class="keyword">for</span> IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">xmlhttp=new XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;// code <span class="keyword">for</span> IE6, IE5</span><br><span class="line">xmlhttp=new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2. 建立连接</span><br><span class="line">/*</span><br><span class="line">参数：</span><br><span class="line">1. 请求方式：GET、POST</span><br><span class="line">* get方式，请求参数在URL后边拼接。send方法为空参</span><br><span class="line">* post方式，请求参数在send方法中定义</span><br><span class="line">2. 请求的URL：</span><br><span class="line">3. 同步或异步请求：<span class="literal">true</span>（异步）或 <span class="literal">false</span>（同步）</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"ajaxServlet?username=tom"</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">//3.发送请求</span><br><span class="line">xmlhttp.send();</span><br><span class="line"></span><br><span class="line">//4.接受并处理来自服务器的响应结果</span><br><span class="line">//获取方式 ：xmlhttp.responseText</span><br><span class="line">//什么时候获取？当服务器响应成功后再获取</span><br><span class="line"></span><br><span class="line">//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。</span><br><span class="line">xmlhttp.onreadystatechange=<span class="keyword">function</span>()</span><br><span class="line">&#123;</span><br><span class="line">//判断readyState就绪状态是否为4，判断status响应状态码是否为200</span><br><span class="line"><span class="keyword">if</span> (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)</span><br><span class="line">&#123;</span><br><span class="line">//获取服务器的响应结果</span><br><span class="line">var responseText = xmlhttp.responseText;</span><br><span class="line">alert(responseText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Jquery实现：</p>
<blockquote>
<p>Jquery是一个JavaScript框架，使用前必须引入依赖jar包 </p>
</blockquote>
<ol>
<li><strong>$.ajax()</strong><ul>
<li>语法：$.ajax({键值对});<br>//使用$.ajax()发送异步请求</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">                url:<span class="string">"ajaxServlet"</span> , // 请求路径</span><br><span class="line">                <span class="built_in">type</span>:<span class="string">"POST"</span> , //请求方式</span><br><span class="line">                //data: <span class="string">"username=jack&amp;age=23"</span>,//请求参数</span><br><span class="line">                data:&#123;<span class="string">"username"</span>:<span class="string">"jack"</span>,<span class="string">"age"</span>:23&#125;,</span><br><span class="line">                success:<span class="keyword">function</span> (data) &#123;</span><br><span class="line">                    alert(data);</span><br><span class="line">                &#125;,//响应成功后的回调函数</span><br><span class="line">                error:<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                    alert(<span class="string">"出错啦..."</span>)</span><br><span class="line">                &#125;,//表示如果请求响应出现错误，会执行的回调函数</span><br><span class="line"></span><br><span class="line">                dataType:<span class="string">"text"</span>//设置接受到的响应数据的格式</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>$.get()</strong>：发送get请求<ul>
<li>语法：$.get(url, [data], [callback], [type]</li>
<li>参数：<ul>
<li>url：请求路径</li>
<li>data:请求参数</li>
<li>callback：回调函数</li>
<li>type: 响应结果类型</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$.get(<span class="string">"user/findOne"</span>,&#123;&#125;,<span class="keyword">function</span> (data) &#123;</span><br><span class="line">            var str = <span class="string">"欢迎回来,"</span>+data.name;</span><br><span class="line">            $(<span class="string">"#span_name"</span>).html(str);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>$.post()</strong>：发送post请求<ul>
<li>语法：$.post(url, [data], [callback], [type])</li>
<li>参数：<ul>
<li>url：请求路径</li>
<li>data:请求参数</li>
<li>callback：回调函数</li>
<li>type: 响应结果类型</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$.post(<span class="string">"user/login"</span>,$(<span class="string">"#loginForm"</span>).serialize(),<span class="keyword">function</span> (data) &#123;</span><br><span class="line">   <span class="keyword">if</span> (data.flag)&#123;</span><br><span class="line">      location.href=<span class="string">"index.html"</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $(<span class="string">"#errorMsg"</span>).html(data.errorMsg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>$(“#id”).serialize()可以把from表单的内容变为键值对形式。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2020/03/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a><center>Linux常用命令</center></h1><h3 id="1-切换目录命令cd"><a href="#1-切换目录命令cd" class="headerlink" title="1.切换目录命令cd"></a>1.切换目录命令cd</h3><p>使用cd app   切换到app目录 </p>
<p>cd ..  切换到上一层目录<br>cd /     切换到系统根目录<br>cd ~   切换到用户主目录<br>cd -     切换到上一个所在目录</p>
<p>使用tab键来补全文件路径</p>
<h3 id="2-列出文件列表：ls-ll"><a href="#2-列出文件列表：ls-ll" class="headerlink" title="2.列出文件列表：ls ll"></a>2.列出文件列表：ls ll</h3><p>ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。</p>
<p>格式：ls[参数] [路径或文件名]</p>
<p>在linux中以 . 开头的文件都是隐藏的文件</p>
<p>ls<br>ls -a 显示所有文件或目录（包含隐藏的文件）<br>ls -l 缩写成ll</p>
<a id="more"></a>

<h3 id="3-创建目录和移除目录：mkdir-rmdir"><a href="#3-创建目录和移除目录：mkdir-rmdir" class="headerlink" title="3.创建目录和移除目录：mkdir rmdir"></a>3.创建目录和移除目录：mkdir rmdir</h3><p>mkdir(make directory)命令可用来创建子目录。<br>mkdir app     在当前目录下创建app目录<br>mkdir –p app2/test  级联创建aap2以及test目<br>rmdir(remove directory)命令可用来删除“空”的子目录:rmdir app  删除app目录</p>
<h3 id="4-浏览文件"><a href="#4-浏览文件" class="headerlink" title="4.浏览文件"></a>4.浏览文件</h3><p><strong>【cat、more、less】</strong></p>
<p>cat用于显示文件的内容。格式：cat[参数]&lt;文件名&gt;</p>
<blockquote>
<p> cat a.txt</p>
</blockquote>
<p>more一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。</p>
<p>回车显示下一行内容。按 q 键退出查看。</p>
<blockquote>
<p>more yum.conf</p>
<p>空格显示下一页数据 回车显示下一行的数据</p>
</blockquote>
<p>less用法和more类似，不同的是less可以通过PgUp、PgDn键来控制.</p>
<blockquote>
<p>less yum.conf</p>
<p>PgUp 和 PgDn 进行上下翻页.</p>
</blockquote>
<p><strong>tail</strong></p>
<p>tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。</p>
<p>用法:</p>
<blockquote>
<p>tail -10 /etc/passwd    查看后10行数据</p>
<p>tail -f catalina.log   动态查看日志</p>
<p>ctrl+c 结束查看</p>
</blockquote>
<h3 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5.文件操作"></a>5.文件操作</h3><p><strong>【rm】</strong></p>
<p>rm 删除文件</p>
<ul>
<li><p>用法：</p>
<blockquote>
<p>rm [选项]… 文件..<br>rm a.txt  删除a.txt文件   删除需要用户确认，y/n<br>rm -f a.txt  不询问，直接删除rm 删除目录<br>rm -r a    递归删除不询问递归删除（慎用）<br>rm -rf a  不询问递归删除<br>rm -rf *    删除所有文件<br>rm -rf /*    删除系统所有文件，危险行为</p>
</blockquote>
</li>
</ul>
<p><strong>【cp、mv】</strong></p>
<p>cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。</p>
<blockquote>
<p>cp a.txt b.txt  将a.txt复制为b.txt文件<br>cp a.txt ../    将a.txt文件复制到上一层目录中</p>
</blockquote>
<p>mv 移动或者重命名：</p>
<blockquote>
<p>mv a.txt ../  将a.txt文件移动到上一层目录中<br>mv a.txt b.txt  将a.txt文件重命名为b.txt</p>
</blockquote>
<p><strong>【tar】命令:( 打包或解压)</strong></p>
<p>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。</p>
<p>常用参数：</p>
<blockquote>
<p>-c：创建一个新tar文件<br>-v：显示运行过程的信息<br>-f：指定文件名<br>-z：调用gzip压缩命令进行压缩<br>-t：查看压缩文件的内容<br>-x：解开tar文件</p>
</blockquote>
<p>打包：</p>
<blockquote>
<p>tar –cvf  xxx.tar  ./*</p>
</blockquote>
<p>打包并且压缩：</p>
<blockquote>
<p> tar –zcvf xxx.tar.gz ./*</p>
</blockquote>
<p>解压 ：tar –xvf xxx.tar</p>
<blockquote>
<p>tar -zxvf xxx.tar.gz -C /usr/aaa</p>
</blockquote>
<p><strong>【find】命令</strong></p>
<p>find指令用于查找符合条件的文件。</p>
<p>示例：</p>
<blockquote>
<p> find / -name “ins*” 查找文件名称是以ins开头的文件</p>
<p>find / -name “ins*” –ls </p>
<p>find / –user ss –ls 查找用户ss的文件</p>
<p>find / –user ss–type d –ls 查找用户ss的目录</p>
<p>find /-perm -777 –type d-ls 查找权限是777的文件</p>
</blockquote>
<p><strong>【grep】命令</strong></p>
<p>查找文件里符合条件的字符串。</p>
<p>用法：</p>
<p>grep [选项]… PATTERN [FILE]…示例：</p>
<p>grep lang anaconda-ks.cfg     在文件中查找lang</p>
<p>grep lang anaconda-ks.cfg –color     高亮显示</p>
<blockquote>
<p>grep debug yum.conf –color</p>
<p>grep debug yum.conf –color  -A5</p>
<p>grep debug yum.conf –color -A5 -B5</p>
</blockquote>
<h3 id="6-其他常用命令"><a href="#6-其他常用命令" class="headerlink" title="6.其他常用命令"></a>6.其他常用命令</h3><p><strong>【pwd】</strong></p>
<p>显示当前所在目录</p>
<p><strong>【touch】</strong></p>
<p>创建一个空文件</p>
<blockquote>
<p>touch a.txt</p>
</blockquote>
<p><strong>【clear/ crtl + L】</strong></p>
<p>清屏</p>
<h3 id="7-VI和Vim编辑器"><a href="#7-VI和Vim编辑器" class="headerlink" title="7.VI和Vim编辑器"></a>7.VI和Vim编辑器</h3><p>在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。三种模式：命令行、插入、底行模式。</p>
<p>切换到命令行模式：按Esc键</p>
<p>切换到插入模式：按 i 、o、a键；</p>
<blockquote>
<p>  i 在当前位置前插入</p>
<p>  I 在当前行首插入</p>
<p>  a 在当前位置后插入</p>
<p>  A 在当前行尾插入</p>
<p>  o 在当前行之后插入一行</p>
<p>  O 在当前行之前插入一行</p>
</blockquote>
<p>打开文件：vim file</p>
<p>退出：esc   :q</p>
<p>修改文件：输入i进入插入模式</p>
<p>保存并退出：esc :wq</p>
<p>不保存退出：esc :q!</p>
<p>三种进入插入模式：</p>
<blockquote>
<p> i:在当前的光标所在处插入<br>o:在当前光标所在的行的下一行插入<br>a:在光标所在的下一个字符插入</p>
</blockquote>
<p>快捷键：</p>
<blockquote>
<p>dd – 快速删除一行</p>
<p>yy - 复制当前行</p>
<p>nyy - 从当前行向后复制几行</p>
<p>p - 粘贴</p>
<p>R – 替换</p>
</blockquote>
<h2 id="8-重定向输出-gt-和-gt-gt"><a href="#8-重定向输出-gt-和-gt-gt" class="headerlink" title="8.重定向输出&gt;和&gt;&gt;"></a>8.重定向输出&gt;和&gt;&gt;</h2><p> 重定向输出，覆盖原有内容；&gt;&gt; 重定向输出，又追加功能；示例：</p>
<blockquote>
<p>cat /etc/passwd &gt; a.txt 将输出定向到a.txt中</p>
<p>cat /etc/passwd &gt;&gt; a.txt 输出并且追加</p>
<p>ifconfig &gt; ifconfig.txt</p>
</blockquote>
<h3 id="9-系统管理命令"><a href="#9-系统管理命令" class="headerlink" title="9.系统管理命令"></a>9.系统管理命令</h3><p>ps 正在运行的某个进程的状态</p>
<blockquote>
<p>ps –ef 查看所有进程</p>
<p>ps –ef | grep ssh 查找某一进程</p>
<p>kill 2868 杀掉2868编号的进程</p>
<p>kill -9 2868 强制杀死进程</p>
</blockquote>
<h3 id="10-管道"><a href="#10-管道" class="headerlink" title="10.管道"></a>10.管道</h3><p>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例：</p>
<blockquote>
<p>ls –help | more 分页查询帮助信息</p>
<p>ps –ef | grep java 查询名称中包含java的进程</p>
<p>ifconfig | more</p>
<p>cat index.html | more</p>
<p>ps –ef | grep aio</p>
</blockquote>
<h3 id="11-LInux权限命令"><a href="#11-LInux权限命令" class="headerlink" title="11.LInux权限命令"></a>11.LInux权限命令</h3><h4 id="11-1文件权限"><a href="#11-1文件权限" class="headerlink" title="11.1文件权限"></a>11.1文件权限</h4><p><img src="/" class="lazyload" data-src="/img/Linux/1.png"  alt=""></p>
<p><img src="/" class="lazyload" data-src="/img/Linux/2.png"  alt=""></p>
<p>r:对文件是指可读取内容 对目录是可以ls</p>
<p>w:对文件是指可修改文件内容，对目录 是指可以在其中创建或删除子节点(目录或文件)</p>
<p>x:对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录</p>
<h4 id="11-2．-Linux三种文件类型："><a href="#11-2．-Linux三种文件类型：" class="headerlink" title="11.2． Linux三种文件类型："></a>11.2． Linux三种文件类型：</h4><blockquote>
<p>普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 </p>
<p>目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 </p>
<p>设备文件： Linux系统把每一个设备都看成是一个文件</p>
</blockquote>
<h4 id="11-3-文件类型标识"><a href="#11-3-文件类型标识" class="headerlink" title="11.3 文件类型标识"></a>11.3 文件类型标识</h4><blockquote>
<p>普通文件（-）目录（d）符号链接（l）</p>
<p>进入etc可以查看，相当于快捷方式字符设备文件（c）块设备文件（s）套接字（s）命名管道（p</p>
</blockquote>
<h4 id="11-4文件权限管理"><a href="#11-4文件权限管理" class="headerlink" title="11.4文件权限管理"></a>11.4文件权限管理</h4><blockquote>
<p>chmod 变更文件或目录的权限。</p>
<p>chmod 755 a.txt </p>
<p>chmod u=rwx,g=rx,o=rx a.txt</p>
</blockquote>
<h3 id="12-Linux上常用网络操作"><a href="#12-Linux上常用网络操作" class="headerlink" title="12.Linux上常用网络操作"></a>12.Linux上常用网络操作</h3><h4 id="12-1-主机名配置"><a href="#12-1-主机名配置" class="headerlink" title="12.1.主机名配置"></a>12.1.主机名配置</h4><blockquote>
<p>hostname 查看主机名</p>
<p>hostname xxx 修改主机名 重启后无效</p>
<p>如果想要永久生效，可以修改/etc/sysconfig/network文件</p>
</blockquote>
<h4 id="12-2-IP地址配置"><a href="#12-2-IP地址配置" class="headerlink" title="12.2.IP地址配置"></a>12.2.IP地址配置</h4><blockquote>
<p>ifconfig 查看(修改)ip地址(重启后无效)</p>
<p>ifconfig eth0 192.168.12.22 修改ip地址</p>
<p>如果想要永久生效</p>
<p>修改 /etc/sysconfig/network-scripts/ifcfg-eth0文件</p>
<p>DEVICE=eth0 #网卡名称</p>
<p>BOOTPROTO=static #获取ip的方式(static/dhcp/bootp/none)</p>
<p>HWADDR=00:0C:29:B5:B2:69 #MAC地址</p>
<p>IPADDR=12.168.177.129 #IP地址<br>NETMASK=255.255.255.0 #子网掩码<br>NETWORK=192.168.177.0 #网络地址<br>BROADCAST=192.168.0.255 #广播地址</p>
<p>NBOOT=yes #  系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。</p>
</blockquote>
<h4 id="12-3-域名映射"><a href="#12-3-域名映射" class="headerlink" title="12.3.域名映射"></a>12.3.域名映射</h4><p>/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用,相当于windows系统的C:\Windows\System32\drivers\etc\hosts文件的功能</p>
<h4 id="12-4-网络服务管理"><a href="#12-4-网络服务管理" class="headerlink" title="12.4.网络服务管理"></a>12.4.网络服务管理</h4><blockquote>
<p>service network status 查看指定服务的状态</p>
<p>service network stop 停止指定服务</p>
<p>service network start 启动指定服务</p>
<p>service network restart 重启指定服务</p>
<p>service –status–all 查看系统中所有后台服务</p>
<p>netstat –nltp 查看系统中网络进程的端口监听情况</p>
<p>防火墙设置</p>
<p>防火墙根据配置文件/etc/sysconfig/iptables来控制本机的”出”、”入”网络访问行为。</p>
<p>service iptables status 查看防火墙状态</p>
<p>service iptables stop 关闭防火墙</p>
<p>service iptables start 启动防火墙</p>
<p>chkconfig iptables off 禁止防火墙自启</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记（五）</title>
    <url>/2020/03/31/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Mybatis学习笔记（五）"><a href="#Mybatis学习笔记（五）" class="headerlink" title="Mybatis学习笔记（五）"></a><center>Mybatis学习笔记（五）</center></h1><h2 id="1-Mybatis-延迟加载策略"><a href="#1-Mybatis-延迟加载策略" class="headerlink" title="1.Mybatis 延迟加载策略"></a>1.Mybatis 延迟加载策略</h2><h3 id="1-1何为延迟加载"><a href="#1-1何为延迟加载" class="headerlink" title="1.1何为延迟加载?"></a>1.1何为延迟加载?</h3><blockquote>
<p>延迟加载：<br>就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载.<br>好处： 先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。<br>坏处：<br>因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗<br>时间，所以可能造成用户等待时间变长，造成用户体验下降  </p>
</blockquote>
<h3 id="1-2-实现需求"><a href="#1-2-实现需求" class="headerlink" title="1.2 实现需求"></a>1.2 实现需求</h3><blockquote>
<p>需求：<br>查询账户(Account)信息并且关联查询用户(User)信息。如果先查询账户(Account)信息即可满足要<br>求，当我们需要查询用户(User)信息时再查询用户(User)信息。把对用户(User)信息的按需去查询就是延迟加<br>载。  </p>
</blockquote>
<a id="more"></a>

<h3 id="1-3-使用-assocation-实现延迟加载"><a href="#1-3-使用-assocation-实现延迟加载" class="headerlink" title="1.3 使用 assocation 实现延迟加载"></a>1.3 使用 assocation 实现延迟加载</h3><p>账户的持久层 DAO 接口  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountDao &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询所有</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;Account&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>账户的持久层映射文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.syx.dao.IAccountDao&quot;&gt;</span><br><span class="line">    &lt;!--定义封装account和user的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;accountUserMao&quot; type&#x3D;&quot;account&quot;&gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;uid&quot; column&#x3D;&quot;uid&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;money&quot; column&#x3D;&quot;money&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--一对一关系映射，配置User的内容--&gt;</span><br><span class="line">        &lt;association property&#x3D;&quot;user&quot; column&#x3D;&quot;uid&quot; javaType&#x3D;&quot;user&quot; select&#x3D;&quot;com.syx.dao.IUserDao.findById&quot;&gt;</span><br><span class="line">        &lt;&#x2F;association&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;accountUserMao&quot;&gt;</span><br><span class="line">    SELECT * from  account</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAccountByUid&quot; resultType&#x3D;&quot;account&quot; parameterType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">        select * from account where uid&#x3D; #&#123;uid&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p><strong>select</strong>： 填写我们要调用的 select 映射的 id<br><strong>column</strong> ： 填写我们要传递给 select 映射的参数  </p>
<p>用户的持久层接口和映射文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据Id查询--&gt;</span><br><span class="line">   &lt;select id&#x3D;&quot;findById&quot; resultType&#x3D;&quot;com.syx.domain.User&quot; parameterType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">       select * from user  where id &#x3D; #&#123;uid&#125;</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<p>开启 Mybatis 的延迟加载策略  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置参数--&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;!--开启延迟加载的全局开关--&gt;</span><br><span class="line">        &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;setting name&#x3D;&quot;aggressiveLazyLoading&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-Mybatis-缓存"><a href="#2-Mybatis-缓存" class="headerlink" title="2.Mybatis 缓存"></a>2.Mybatis 缓存</h2><h3 id="2-1Mybatis-一级缓存"><a href="#2-1Mybatis-一级缓存" class="headerlink" title="2.1Mybatis 一级缓存"></a>2.1Mybatis 一级缓存</h3><blockquote>
<p>一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除， commit()， close()等  方法时，就会清空一级缓存。  </p>
</blockquote>
<h3 id="2-2Mybatis-二级缓存"><a href="#2-2Mybatis-二级缓存" class="headerlink" title="2.2Mybatis 二级缓存"></a>2.2Mybatis 二级缓存</h3><p>二级缓存的开启与关闭 :</p>
<p>第一步：在 SqlMapConfig.xml 文件开启二级缓存  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启二级缓存的支持 --&gt;</span><br><span class="line">&lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br><span class="line">因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为</span><br><span class="line">false 代表不开启二级缓存</span><br></pre></td></tr></table></figure>

<p>第二步：配置相关的 Mapper 映射文件 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;cache&gt;标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.itheima.dao.IUserDao&quot;&gt;</span><br><span class="line">&lt;!-- 开启二级缓存的支持 --&gt;</span><br><span class="line">&lt;cache&gt;&lt;&#x2F;cache&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>第三步： 配置 statement 上面的 useCache 属性  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据 id 查询 --&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findById&quot; resultType&#x3D;&quot;user&quot; parameterType&#x3D;&quot;int&quot; useCache&#x3D;&quot;true&quot;&gt;</span><br><span class="line">select * from user where id &#x3D; #&#123;uid&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache&#x3D;”true”代表当前这个 statement 要使用</span><br><span class="line">二级缓存，如果不使用二级缓存可以设置为 false。</span><br><span class="line">注意： 针对每次查询都需要最新的数据 sql，要设置成 useCache&#x3D;false，禁用二级缓存。</span><br></pre></td></tr></table></figure>

<h2 id="3-使用注解实现复杂关系映射开发"><a href="#3-使用注解实现复杂关系映射开发" class="headerlink" title="3.使用注解实现复杂关系映射开发"></a>3.使用注解实现复杂关系映射开发</h2><h3 id="3-1复杂关系映射的注解说明"><a href="#3-1复杂关系映射的注解说明" class="headerlink" title="3.1复杂关系映射的注解说明"></a>3.1复杂关系映射的注解说明</h3><blockquote>
<p>@Results 注解<br>代替的是标签<resultMap><br>该注解中可以使用单个@Result 注解，也可以使用@Result 集合<br>@Results（{@Result（）， @Result（） }）或@Results（@Result（））<br>@Resutl 注解<br>代替了 <id>标签和<result>标签<br>@Result 中 属性介绍：<br>id 是否是主键字段<br>column 数据库的列名<br>property 需要装配的属性名</p>
<p>one 需要使用的@One 注解（@Result（one=@One）（）））</p>
<p>many 需要使用的@Many 注解（@Result（many=@many）（）））</p>
<p>@One 注解（一对一）<br>代替了<assocation>标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。<br>@One 注解属性介绍：<br>select 指定用来多表查询的 sqlmapper<br>fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。。<br>使用格式：<br>@Result(column=” “,property=””,one=@One(select=””))<br>@Many 注解（多对一）<br>代替了<Collection>标签,是是多表查询的关键，在注解中用来指定子查询返回对象集合。<br>注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType<br>（一般为 ArrayList）但是注解中可以不定义；<br>使用格式：<br>@Result(property=””,column=””,many=@Many(select=””))</p>
</blockquote>
<h3 id="3-2使用注解实现一对一复杂关系映射及延迟加载"><a href="#3-2使用注解实现一对一复杂关系映射及延迟加载" class="headerlink" title="3.2使用注解实现一对一复杂关系映射及延迟加载"></a>3.2使用注解实现一对一复杂关系映射及延迟加载</h3><p>添加 User 实体类及 Account 实体类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">private Integer userId;</span><br><span class="line">private String userName;</span><br><span class="line">private Date userBirthday;</span><br><span class="line">private String userSex;</span><br><span class="line">private String userAddress;</span><br><span class="line">public Integer getUserId() &#123;</span><br><span class="line">return userId;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserId(Integer userId) &#123;</span><br><span class="line">this.userId &#x3D; userId;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserName() &#123;</span><br><span class="line">return userName;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserName(String userName) &#123;</span><br><span class="line">this.userName &#x3D; userName;</span><br><span class="line">&#125;</span><br><span class="line">public Date getUserBirthday() &#123;</span><br><span class="line">return userBirthday;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserBirthday(Date userBirthday) &#123;</span><br><span class="line">this.userBirthday &#x3D; userBirthday;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserSex() &#123;</span><br><span class="line">return userSex;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserSex(String userSex) &#123;</span><br><span class="line">this.userSex &#x3D; userSex;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserAddress() &#123;</span><br><span class="line">return userAddress;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserAddress(String userAddress) &#123;</span><br><span class="line">this.userAddress &#x3D; userAddress;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;User [userId&#x3D;&quot; + userId + &quot;, userName&#x3D;&quot; + userName + &quot;, userBirthday&#x3D;&quot;</span><br><span class="line">+ userBirthday + &quot;, userSex&#x3D;&quot;</span><br><span class="line">+ userSex + &quot;, userAddress&#x3D;&quot; + userAddress + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account implements Serializable &#123;</span><br><span class="line">private Integer id;</span><br><span class="line">private Integer uid;</span><br><span class="line">private Double money;</span><br><span class="line">&#x2F;&#x2F;多对一关系映射：从表方应该包含一个主表方的对象引用</span><br><span class="line">private User user;</span><br><span class="line">public User getUser() &#123;</span><br><span class="line">return user;</span><br><span class="line">&#125;</span><br><span class="line">public void setUser(User user) &#123;</span><br><span class="line">this.user &#x3D; user;</span><br><span class="line">&#125;</span><br><span class="line">public Integer getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(Integer id) &#123;</span><br><span class="line">this.id &#x3D; id;</span><br><span class="line">&#125;</span><br><span class="line">public Integer getUid() &#123;</span><br><span class="line">return uid;</span><br><span class="line">&#125;</span><br><span class="line">public void setUid(Integer uid) &#123;this.uid &#x3D; uid;</span><br><span class="line">&#125;</span><br><span class="line">public Double getMoney() &#123;</span><br><span class="line">return money;</span><br><span class="line">&#125;</span><br><span class="line">public void setMoney(Double money) &#123;</span><br><span class="line">this.money &#x3D; money;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Account [id&#x3D;&quot; + id + &quot;, uid&#x3D;&quot; + uid + &quot;, money&#x3D;&quot; + money + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加账户的持久层接口并使用注解配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountDao &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 查询所有账户，采用延迟加载的方式查询账户的所属用户</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Select(&quot;select * from account&quot;)</span><br><span class="line">@Results(id&#x3D;&quot;accountMap&quot;,</span><br><span class="line">value&#x3D; &#123;</span><br><span class="line">@Result(id&#x3D;true,column&#x3D;&quot;id&quot;,property&#x3D;&quot;id&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;uid&quot;,property&#x3D;&quot;uid&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;money&quot;,property&#x3D;&quot;money&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;uid&quot;,</span><br><span class="line">property&#x3D;&quot;user&quot;,</span><br><span class="line">one&#x3D;@One(select&#x3D;&quot;com.itheima.dao.IUserDao.findById&quot;,</span><br><span class="line">fetchType&#x3D;FetchType.LAZY)</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;Account&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加用户的持久层接口并使用注解配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IUserDao &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 查询所有用户</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Select(&quot;select * from user&quot;)</span><br><span class="line">@Results(id&#x3D;&quot;userMap&quot;,</span><br><span class="line">value&#x3D; &#123;</span><br><span class="line">@Result(id&#x3D;true,column&#x3D;&quot;id&quot;,property&#x3D;&quot;userId&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;username&quot;,property&#x3D;&quot;userName&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;sex&quot;,property&#x3D;&quot;userSex&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;address&quot;,property&#x3D;&quot;userAddress&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;birthday&quot;,property&#x3D;&quot;userBirthday&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;User&gt; findAll();</span><br><span class="line">&#x2F;**</span><br><span class="line">* 根据 id 查询一个用户</span><br><span class="line">* @param userId</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Select(&quot;select * from user where id &#x3D; #&#123;uid&#125; &quot;)</span><br><span class="line">@ResultMap(&quot;userMap&quot;)</span><br><span class="line">User findById(Integer userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3使用注解实现一对多复杂关系映射"><a href="#3-3使用注解实现一对多复杂关系映射" class="headerlink" title="3.3使用注解实现一对多复杂关系映射"></a>3.3使用注解实现一对多复杂关系映射</h3><blockquote>
<p> User 实体类加入 List<Account>  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">private Integer userId;</span><br><span class="line">private String userName;</span><br><span class="line">private Date userBirthday;</span><br><span class="line">private String userSex;</span><br><span class="line">private String userAddress;</span><br><span class="line">&#x2F;&#x2F;一对多关系映射：主表方法应该包含一个从表方的集合引用</span><br><span class="line">private List&lt;Account&gt; accounts;</span><br><span class="line">public List&lt;Account&gt; getAccounts() &#123;</span><br><span class="line">return accounts;</span><br><span class="line">&#125;</span><br><span class="line">public void setAccounts(List&lt;Account&gt; accounts) &#123;this.accounts &#x3D; accounts;</span><br><span class="line">&#125;</span><br><span class="line">public Integer getUserId() &#123;</span><br><span class="line">return userId;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserId(Integer userId) &#123;</span><br><span class="line">this.userId &#x3D; userId;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserName() &#123;</span><br><span class="line">return userName;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserName(String userName) &#123;</span><br><span class="line">this.userName &#x3D; userName;</span><br><span class="line">&#125;</span><br><span class="line">public Date getUserBirthday() &#123;</span><br><span class="line">return userBirthday;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserBirthday(Date userBirthday) &#123;</span><br><span class="line">this.userBirthday &#x3D; userBirthday;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserSex() &#123;</span><br><span class="line">return userSex;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserSex(String userSex) &#123;</span><br><span class="line">this.userSex &#x3D; userSex;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserAddress() &#123;</span><br><span class="line">return userAddress;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserAddress(String userAddress) &#123;</span><br><span class="line">this.userAddress &#x3D; userAddress;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;User [userId&#x3D;&quot; + userId + &quot;, userName&#x3D;&quot; + userName + &quot;, userBirthday&#x3D;&quot;</span><br><span class="line">+ userBirthday + &quot;, userSex&#x3D;&quot;</span><br><span class="line">+ userSex + &quot;, userAddress&#x3D;&quot; + userAddress + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写用户的持久层接口并使用注解配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IUserDao &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 查询所有用户</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Select(&quot;select * from user&quot;)</span><br><span class="line">@Results(id&#x3D;&quot;userMap&quot;,</span><br><span class="line">value&#x3D; &#123;</span><br><span class="line">@Result(id&#x3D;true,column&#x3D;&quot;id&quot;,property&#x3D;&quot;userId&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;username&quot;,property&#x3D;&quot;userName&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;sex&quot;,property&#x3D;&quot;userSex&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;address&quot;,property&#x3D;&quot;userAddress&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;birthday&quot;,property&#x3D;&quot;userBirthday&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;id&quot;,property&#x3D;&quot;accounts&quot;,</span><br><span class="line">many&#x3D;@Many(</span><br><span class="line">select&#x3D;&quot;com.itheima.dao.IAccountDao.findByUid&quot;,</span><br><span class="line">fetchType&#x3D;FetchType.LAZY</span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br><span class="line">@Many:</span><br><span class="line">相当于&lt;collection&gt;的配置</span><br><span class="line">select 属性：代表将要执行的 sql 语句</span><br><span class="line">fetchType 属性：代表加载方式，一般如果要延迟加载都设置为 LAZY 的值</span><br></pre></td></tr></table></figure>

<p>编写账户的持久层接口并使用注解配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountDao &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 根据用户 id 查询用户下的所有账户</span><br><span class="line">* @param userId</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Select(&quot;select * from account where uid &#x3D; #&#123;uid&#125; &quot;)</span><br><span class="line">List&lt;Account&gt; findByUid(Integer userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4mybatis-基于注解的二级缓存"><a href="#3-4mybatis-基于注解的二级缓存" class="headerlink" title="3.4mybatis 基于注解的二级缓存"></a>3.4mybatis 基于注解的二级缓存</h3><p>在 SqlMapConfig 中开启二级缓存支持  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置二级缓存 --&gt;</span><br><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;!-- 开启二级缓存的支持 --&gt;</span><br><span class="line">&lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>

<p>在持久层接口中使用注解配置二级缓存  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CacheNamespace(blocking&#x3D;true)&#x2F;&#x2F;mybatis 基于注解方式实现配置二级缓存</span><br><span class="line">public interface IUserDao &#123;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2020/03/24/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-Docker简介"><a href="#1-Docker简介" class="headerlink" title="1 Docker简介"></a>1 Docker简介</h1><h2 id="1-1-什么是虚拟化"><a href="#1-1-什么是虚拟化" class="headerlink" title="1.1 什么是虚拟化"></a>1.1 什么是虚拟化</h2><p>​    在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</p>
<p>​    在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件   对资源充分利用</p>
<p>​    虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。</p>
<a id="more"></a>

<h2 id="1-2-什么是Docker"><a href="#1-2-什么是Docker" class="headerlink" title="1.2 什么是Docker"></a>1.2 什么是Docker</h2><p>​    Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 <a href="https://github.com/docker/docker" target="_blank" rel="noopener">GitHub</a> 上进行维护。</p>
<p>​    <img src="/" class="lazyload" data-src="/img/docker/1-3.png"  alt=""></p>
<p>​    Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p>
<p>​    Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。</p>
<p>​    在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p>
<p>为什么选择Docker?</p>
<p>（1）上手快。</p>
<p>​    用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”(copy-on-write)模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。<br>​    随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</p>
<p>（2）职责的逻辑分类</p>
<p>​    使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”</p>
<p>（3）快速高效的开发生命周期</p>
<p>​    Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）</p>
<p>（4）鼓励使用面向服务的架构</p>
<p>​    Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）</p>
<h2 id="1-3-容器与虚拟机比较"><a href="#1-3-容器与虚拟机比较" class="headerlink" title="1.3 容器与虚拟机比较"></a>1.3 容器与虚拟机比较</h2><p>​    下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p>
<p><img src="/" class="lazyload" data-src="/img/docker/1-1.png"  alt=""></p>
<p>与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。</p>
<h2 id="1-4-Docker-组件"><a href="#1-4-Docker-组件" class="headerlink" title="1.4 Docker 组件"></a>1.4 Docker 组件</h2><h3 id="1-4-1-Docker服务器与客户端"><a href="#1-4-1-Docker服务器与客户端" class="headerlink" title="1.4.1 Docker服务器与客户端"></a>1.4.1 Docker服务器与客户端</h3><p>​    Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</p>
<p><img src="/" class="lazyload" data-src="/img/docker/1-2.png"  alt=""></p>
<h3 id="1-4-2-Docker镜像与容器"><a href="#1-4-2-Docker镜像与容器" class="headerlink" title="1.4.2 Docker镜像与容器"></a>1.4.2 Docker镜像与容器</h3><p>​    镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如：</p>
<p>添加一个文件；</p>
<p>执行一个命令；</p>
<p>打开一个窗口。</p>
<p>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。</p>
<p>​    Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。  容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</p>
<p>所以Docker容器就是：</p>
<p>​    一个镜像格式；</p>
<p>​    一些列标准操作；</p>
<p>​    一个执行环境。</p>
<p>​    Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。<br>​    和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。<br>​    Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。</p>
<h3 id="1-4-3-Registry（注册中心）"><a href="#1-4-3-Registry（注册中心）" class="headerlink" title="1.4.3 Registry（注册中心）"></a>1.4.3 Registry（注册中心）</h3><p>​    Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。</p>
<p>​    <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<h1 id="2-Docker安装与启动"><a href="#2-Docker安装与启动" class="headerlink" title="2 Docker安装与启动"></a>2 Docker安装与启动</h1><h2 id="2-1-安装Docker"><a href="#2-1-安装Docker" class="headerlink" title="2.1 安装Docker"></a>2.1 安装Docker</h2><p>​    Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p>
<p>​    由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。</p>
<p>​    请直接挂载课程配套的Centos7.x镜像    </p>
<p>(1)yum 包更新到最新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>

<p>（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>（3）设置yum源为阿里云</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>（4）安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>

<p>（5）安装后查看docker版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>

<h2 id="2-2-设置ustc的镜像"><a href="#2-2-设置ustc的镜像" class="headerlink" title="2.2 设置ustc的镜像"></a>2.2 设置ustc的镜像</h2><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。</p>
<p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p>
<p>编辑该文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure>

<p>在该文件中输入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-Docker的启动与停止"><a href="#2-3-Docker的启动与停止" class="headerlink" title="2.3 Docker的启动与停止"></a>2.3 Docker的启动与停止</h2><p><strong>systemctl</strong>命令是系统服务管理器指令</p>
<p>启动docker：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>停止docker：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<p>重启docker：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>查看docker状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p>开机启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>查看docker概要信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>查看docker帮助文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure>

<h1 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3 常用命令"></a>3 常用命令</h1><h2 id="3-1-镜像相关命令"><a href="#3-1-镜像相关命令" class="headerlink" title="3.1 镜像相关命令"></a>3.1 镜像相关命令</h2><h3 id="3-1-1-查看镜像"><a href="#3-1-1-查看镜像" class="headerlink" title="3.1.1 查看镜像"></a>3.1.1 查看镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>REPOSITORY：镜像名称</p>
<p>TAG：镜像标签</p>
<p>IMAGE ID：镜像ID</p>
<p>CREATED：镜像的创建日期（不是获取该镜像的日期）</p>
<p>SIZE：镜像大小</p>
<p>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p>
<h3 id="3-1-2-搜索镜像"><a href="#3-1-2-搜索镜像" class="headerlink" title="3.1.2 搜索镜像"></a>3.1.2 搜索镜像</h3><p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure>

<p>NAME：仓库名称</p>
<p>DESCRIPTION：镜像描述</p>
<p>STARS：用户评价，反应一个镜像的受欢迎程度</p>
<p>OFFICIAL：是否官方</p>
<p>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</p>
<h3 id="3-1-3-拉取镜像"><a href="#3-1-3-拉取镜像" class="headerlink" title="3.1.3 拉取镜像"></a>3.1.3 拉取镜像</h3><p>拉取镜像就是从中央仓库中下载镜像到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名称</span><br></pre></td></tr></table></figure>

<p>例如，我要下载centos7镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull centos:7</span><br></pre></td></tr></table></figure>

<h3 id="3-1-4-删除镜像"><a href="#3-1-4-删除镜像" class="headerlink" title="3.1.4 删除镜像"></a>3.1.4 删除镜像</h3><p>按镜像ID删除镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure>

<p>删除所有镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi &#96;docker images -q&#96;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-容器相关命令"><a href="#3-2-容器相关命令" class="headerlink" title="3.2 容器相关命令"></a>3.2 容器相关命令</h2><h3 id="3-2-1-查看容器"><a href="#3-2-1-查看容器" class="headerlink" title="3.2.1 查看容器"></a>3.2.1 查看容器</h3><p>查看正在运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>查看所有容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps –a</span><br></pre></td></tr></table></figure>

<p>查看最后一次运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps –l</span><br></pre></td></tr></table></figure>

<p>查看停止的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -f status&#x3D;exited</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-创建与启动容器"><a href="#3-2-2-创建与启动容器" class="headerlink" title="3.2.2 创建与启动容器"></a>3.2.2 创建与启动容器</h3><p>创建容器常用的参数说明：</p>
<p>创建容器命令：docker run</p>
<p> -i：表示运行容器</p>
<p> -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</p>
<p> –name :为创建的容器命名。</p>
<p> -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</p>
<p> -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</p>
<p> -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</p>
<p>（1）交互式方式创建容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name&#x3D;容器名称 镜像名称:标签 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态  </p>
<p>退出当前容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>（2）守护式方式创建容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;容器名称 镜像名称:标签</span><br></pre></td></tr></table></figure>

<p>登录守护式容器方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名称 (或者容器ID)  &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-停止与启动容器"><a href="#3-2-3-停止与启动容器" class="headerlink" title="3.2.3 停止与启动容器"></a>3.2.3 停止与启动容器</h3><p>停止容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure>

<p>启动容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-文件拷贝"><a href="#3-2-4-文件拷贝" class="headerlink" title="3.2.4 文件拷贝"></a>3.2.4 文件拷贝</h3><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure>

<p>也可以将文件从容器内拷贝出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure>

<h3 id="3-2-5-目录挂载"><a href="#3-2-5-目录挂载" class="headerlink" title="3.2.5 目录挂载"></a>3.2.5 目录挂载</h3><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。<br>创建容器 添加-v参数 后边为   宿主机目录:容器目录，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml --name&#x3D;mycentos3 centos:7</span><br></pre></td></tr></table></figure>

<p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p>
<p>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数  –privileged=true  来解决挂载的目录没有权限的问题</p>
<h3 id="3-2-6-查看容器IP地址"><a href="#3-2-6-查看容器IP地址" class="headerlink" title="3.2.6 查看容器IP地址"></a>3.2.6 查看容器IP地址</h3><p>我们可以通过以下命令查看容器运行的各种数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名称（容器ID）</span><br></pre></td></tr></table></figure>

<p>也可以直接执行下面的命令直接输出IP地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; 容器名称（容器ID）</span><br></pre></td></tr></table></figure>

<h3 id="3-2-7-删除容器"><a href="#3-2-7-删除容器" class="headerlink" title="3.2.7 删除容器"></a>3.2.7 删除容器</h3><p>删除指定的容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 容器名称（容器ID）</span><br></pre></td></tr></table></figure>

<h1 id="4-应用部署"><a href="#4-应用部署" class="headerlink" title="4 应用部署"></a>4 应用部署</h1><h2 id="4-1-MySQL部署"><a href="#4-1-MySQL部署" class="headerlink" title="4.1 MySQL部署"></a>4.1 MySQL部署</h2><p>（1）拉取mysql镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull centos&#x2F;mysql-57-centos7</span><br></pre></td></tr></table></figure>

<p>（2）创建容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql</span><br></pre></td></tr></table></figure>

<p>-p 代表端口映射，格式为  宿主机映射端口:容器运行端口</p>
<p>-e 代表添加环境变量  MYSQL_ROOT_PASSWORD  是root用户的登陆密码</p>
<p>（3）远程登录mysql</p>
<p>连接宿主机的IP  ,指定端口为33306 </p>
<h2 id="4-2-tomcat部署"><a href="#4-2-tomcat部署" class="headerlink" title="4.2 tomcat部署"></a>4.2 tomcat部署</h2><p>（1）拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull tomcat:7-jre7</span><br></pre></td></tr></table></figure>

<p>（2）创建容器</p>
<p>创建容器  -p表示地址映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;mytomcat -p 9000:8080 </span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;webapps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps tomcat:7-jre7</span><br></pre></td></tr></table></figure>

<h2 id="4-3-Nginx部署"><a href="#4-3-Nginx部署" class="headerlink" title="4.3 Nginx部署"></a>4.3 Nginx部署</h2><p>（1）拉取镜像    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<p>（2）创建Nginx容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>

<h2 id="4-4-Redis部署"><a href="#4-4-Redis部署" class="headerlink" title="4.4 Redis部署"></a>4.4 Redis部署</h2><p>（1）拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>

<p>（2）创建容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure>

<h1 id="5-迁移与备份"><a href="#5-迁移与备份" class="headerlink" title="5 迁移与备份"></a>5 迁移与备份</h1><h2 id="5-1-容器保存为镜像"><a href="#5-1-容器保存为镜像" class="headerlink" title="5.1 容器保存为镜像"></a>5.1 容器保存为镜像</h2><p>我们可以通过以下命令将容器保存为镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit mynginx mynginx_i</span><br></pre></td></tr></table></figure>

<h2 id="5-2-镜像备份"><a href="#5-2-镜像备份" class="headerlink" title="5.2 镜像备份"></a>5.2 镜像备份</h2><p>我们可以通过以下命令将镜像保存为tar 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker  save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure>

<h2 id="5-3-镜像恢复与迁移"><a href="#5-3-镜像恢复与迁移" class="headerlink" title="5.3 镜像恢复与迁移"></a>5.3 镜像恢复与迁移</h2><p>首先我们先删除掉mynginx_img镜像  然后执行此命令进行恢复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i mynginx.tar</span><br></pre></td></tr></table></figure>

<p>-i 输入的文件</p>
<p>执行后再次查看镜像，可以看到镜像已经恢复</p>
<h1 id="6-Dockerfile"><a href="#6-Dockerfile" class="headerlink" title="6 Dockerfile"></a>6 Dockerfile</h1><h2 id="6-1-什么是Dockerfile"><a href="#6-1-什么是Dockerfile" class="headerlink" title="6.1 什么是Dockerfile"></a>6.1 什么是Dockerfile</h2><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p>
<p>1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；<br>2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；<br>3、对于运维人员：在部署时，可以实现应用的无缝移植。</p>
<h2 id="6-2-常用命令"><a href="#6-2-常用命令" class="headerlink" title="6.2 常用命令"></a>6.2 常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>FROM image_name:tag</td>
<td>定义了使用哪个基础镜像启动构建流程</td>
</tr>
<tr>
<td>MAINTAINER user_name</td>
<td>声明镜像的创建者</td>
</tr>
<tr>
<td>ENV key value</td>
<td>设置环境变量 (可以写多条)</td>
</tr>
<tr>
<td>RUN command</td>
<td>是Dockerfile的核心部分(可以写多条)</td>
</tr>
<tr>
<td>ADD source_dir/file dest_dir/file</td>
<td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td>
</tr>
<tr>
<td>COPY source_dir/file dest_dir/file</td>
<td>和ADD相似，但是如果有压缩文件并不能解压</td>
</tr>
<tr>
<td>WORKDIR path_dir</td>
<td>设置工作目录</td>
</tr>
</tbody></table>
<h2 id="6-3-使用脚本创建镜像"><a href="#6-3-使用脚本创建镜像" class="headerlink" title="6.3 使用脚本创建镜像"></a>6.3 使用脚本创建镜像</h2><p>步骤：</p>
<p>（1）创建目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir –p &#x2F;usr&#x2F;local&#x2F;dockerjdk8</span><br></pre></td></tr></table></figure>

<p>（2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录</p>
<p>（3）创建文件Dockerfile  <code>vi Dockerfile</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#依赖镜像名称和ID</span><br><span class="line">FROM centos:7</span><br><span class="line">#指定镜像创建者信息</span><br><span class="line">MAINTAINER ITCAST</span><br><span class="line">#切换工作目录</span><br><span class="line">WORKDIR &#x2F;usr</span><br><span class="line">RUN mkdir  &#x2F;usr&#x2F;local&#x2F;java</span><br><span class="line">#ADD 是相对路径jar,把java添加到容器中</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;</span><br><span class="line"></span><br><span class="line">#配置java环境变量</span><br><span class="line">ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_171</span><br><span class="line">ENV JRE_HOME $JAVA_HOME&#x2F;jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<p>（4）执行命令构建镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t&#x3D;&#39;jdk1.8&#39; .</span><br></pre></td></tr></table></figure>

<p>注意后边的空格和点，不要省略</p>
<p>（5）查看镜像是否建立完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>



<h1 id="7-Docker私有仓库"><a href="#7-Docker私有仓库" class="headerlink" title="7 Docker私有仓库"></a>7 Docker私有仓库</h1><h2 id="7-1-私有仓库搭建与配置"><a href="#7-1-私有仓库搭建与配置" class="headerlink" title="7.1 私有仓库搭建与配置"></a>7.1 私有仓库搭建与配置</h2><p>（1）拉取私有仓库镜像（此步省略）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure>

<p>（2）启动私有仓库容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;registry -p 5000:5000 registry</span><br></pre></td></tr></table></figure>

<p>（3）打开浏览器 输入地址http://你的IP地址:5000/v2/_catalog看到<code>{&quot;repositories&quot;:[]}</code> 表示私有仓库搭建成功并且内容为空</p>
<p>（4）修改daemon.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure>

<p>添加以下内容，保存退出。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"insecure-registries"</span>:[<span class="string">"你的IP地址:5000"</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>此步用于让 docker信任私有仓库地址</p>
<p>（5）重启docker 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="7-2-镜像上传至私有仓库"><a href="#7-2-镜像上传至私有仓库" class="headerlink" title="7.2 镜像上传至私有仓库"></a>7.2 镜像上传至私有仓库</h2><p>（1）标记此镜像为私有仓库的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag jdk1.8 你的IP地址:5000&#x2F;jdk1.8</span><br></pre></td></tr></table></figure>

<p>（2）再次启动私服容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start registry</span><br></pre></td></tr></table></figure>

<p>（3）上传标记的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker push 你的IP地址:5000&#x2F;jdk1.8</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringIoc（基于xml配置）</title>
    <url>/2020/04/03/SpringIoc%EF%BC%88%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-SpringIoc的概念和作用"><a href="#1-SpringIoc的概念和作用" class="headerlink" title="1.SpringIoc的概念和作用"></a>1.SpringIoc的概念和作用</h2><h3 id="1-1程序的耦合和解耦"><a href="#1-1程序的耦合和解耦" class="headerlink" title="1.1程序的耦合和解耦 "></a><CENTER>1.1程序的耦合和解耦 <CENTER></h3><h4 id="1-1-1什么是程序的耦合"><a href="#1-1-1什么是程序的耦合" class="headerlink" title="1.1.1什么是程序的耦合?"></a>1.1.1什么是程序的耦合?</h4><blockquote>
<p>耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调<br>用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。 耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。<br>在软件工程中， 耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。 软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。 划分模块的一个准则就是高内聚低耦合。</p>
<a id="more"></a>
<p>它有如下分类：<br>（1） 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另 一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。<br>（2） 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大 量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。<br>（3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。<br>（4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进 行适当的动作，这种耦合被称为控制耦合。<br>（5） 标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间 存在一个标记耦合。<br>（6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。<br>（7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实 现的。<br>总结：<br>耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须 存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。<br>内聚与耦合内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。 内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。<br>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p>
</blockquote>
<h4 id="1-1-2解决耦合思路"><a href="#1-1-2解决耦合思路" class="headerlink" title="1.1.2解决耦合思路"></a>1.1.2解决耦合思路</h4><blockquote>
<p>当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下：<br>Class.forName(“com.mysql.jdbc.Driver”);//此处只是一个字符串<br>此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运行就不要想了，没有驱动不可能运行成功的） 。<br>同时，也产生了一个新的问题， mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改 源码。<br>解决这个问题也很简单，使用配置文件配置  </p>
</blockquote>
<h4 id="1-1-3工厂模式解耦"><a href="#1-1-3工厂模式解耦" class="headerlink" title="1.1.3工厂模式解耦"></a>1.1.3工厂模式解耦</h4><blockquote>
<p>在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候， 让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。<br>那么，这个读取配置文件， 创建和获取三层对象的类就是工厂</p>
</blockquote>
<h4 id="1-1-4控制反转-Inversion-Of-Control"><a href="#1-1-4控制反转-Inversion-Of-Control" class="headerlink" title="1.1.4控制反转-Inversion Of Control"></a>1.1.4控制反转-Inversion Of Control</h4><blockquote>
<p>解耦的思路有 2 个问题：<br>1、存哪去？<br>分析：由于我们是很多对象，肯定要找个集合来存。这时候有 Map 和 List 供选择。<br>到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。<br>所以我们的答案就是<br>在应用加载时，创建一个 Map，用于存放三层对象。<br>我们把这个 map 称之为容器。<br>2、还是没解释什么是工厂？<br>工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。<br>原来：<br>我们在获取对象时，都是采用 new 的方式。 是主动的。<br>现在：<br>我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。 是被动的。<br>这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。<br><strong>明确 ioc 的作用</strong>：<br>削减计算机程序的耦合(解除我们代码中的依赖关系)。  </p>
</blockquote>
<h2 id="2-使用-spring-的-IOC-解决程序耦合"><a href="#2-使用-spring-的-IOC-解决程序耦合" class="headerlink" title="2.使用 spring 的 IOC 解决程序耦合"></a><center>2.使用 spring 的 IOC 解决程序耦合</center></h2><h3 id="2-1案例的前期准备"><a href="#2-1案例的前期准备" class="headerlink" title="2.1案例的前期准备"></a>2.1案例的前期准备</h3><h4 id="2-1-1导入依赖"><a href="#2-1-1导入依赖" class="headerlink" title="2.1.1导入依赖"></a>2.1.1导入依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2创建业务层接口和实现类"><a href="#2-1-2创建业务层接口和实现类" class="headerlink" title="2.1.2创建业务层接口和实现类"></a>2.1.2创建业务层接口和实现类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 模拟保存用户</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void saveAccount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line">    private IAccountDao accountDao &#x3D; new AccountDaoImpl();</span><br><span class="line"></span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3创建持久层接口和实现类"><a href="#2-1-3创建持久层接口和实现类" class="headerlink" title="2.1.3创建持久层接口和实现类"></a>2.1.3创建持久层接口和实现类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountDao &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 模拟保存用户</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void saveAccount(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        System.out.println(&quot;账户保存了................&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-基于-XML-的配置"><a href="#2-2-基于-XML-的配置" class="headerlink" title="2.2 基于 XML 的配置"></a>2.2 基于 XML 的配置</h3><h4 id="2-2-1在resource下创建xml配置文件，导入约束"><a href="#2-2-1在resource下创建xml配置文件，导入约束" class="headerlink" title="2.2.1在resource下创建xml配置文件，导入约束"></a>2.2.1在resource下创建xml配置文件，导入约束</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2让-spring-管理资源，在配置文件中配置-service-和-dao"><a href="#2-2-2让-spring-管理资源，在配置文件中配置-service-和-dao" class="headerlink" title="2.2.2让 spring 管理资源，在配置文件中配置 service 和 dao"></a>2.2.2让 spring 管理资源，在配置文件中配置 service 和 dao</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">        &lt;!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中</span><br><span class="line">        id 属性：对象的唯一标识。</span><br><span class="line">        class 属性：指定要创建对象的全限定类名</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;!--配置Service--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.syx.service.Impl.AccountServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!--配置Dao--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;accountDao&quot; class&#x3D;&quot;com.syx.dao.Impl.AccountDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3测试配置是否成功"><a href="#2-2-3测试配置是否成功" class="headerlink" title="2.2.3测试配置是否成功"></a>2.2.3测试配置是否成功</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;使用ApplicationContext接口，获取spring容器</span><br><span class="line">        ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;根基bean的id获取对象 </span><br><span class="line">        AccountServiceImpl accountService &#x3D; ac.getBean(&quot;accountService&quot;, AccountServiceImpl.class);</span><br><span class="line">        System.out.println(accountService);</span><br><span class="line">        AccountDaoImpl accountDao &#x3D; ac.getBean(&quot;accountDao&quot;, AccountDaoImpl.class);</span><br><span class="line">        System.out.println(accountDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Spring基于xml的Ioc细节"><a href="#3-Spring基于xml的Ioc细节" class="headerlink" title="3.Spring基于xml的Ioc细节"></a><center>3.Spring基于xml的Ioc细节</center></h2><p>spring 中工厂的类结构图  </p>
<p><img src="/" class="lazyload" data-src="/img/Spring/1.png"  alt=""></p>
<h3 id="3-1BeanFactory-和-ApplicationContext-的区别"><a href="#3-1BeanFactory-和-ApplicationContext-的区别" class="headerlink" title="3.1BeanFactory 和 ApplicationContext 的区别"></a>3.1BeanFactory 和 ApplicationContext 的区别</h3><blockquote>
<p>BeanFactory 才是 Spring 容器中的顶层接口。<br>ApplicationContext 是它的子接口。<br>BeanFactory 和 ApplicationContext 的区别：<br>创建对象的时间点不一样。<br>ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。<br>BeanFactory：什么使用什么时候创建对象。  </p>
</blockquote>
<h3 id="3-2ApplicationContext-接口的实现类"><a href="#3-2ApplicationContext-接口的实现类" class="headerlink" title="3.2ApplicationContext 接口的实现类"></a>3.2ApplicationContext 接口的实现类</h3><blockquote>
<p>ClassPathXmlApplicationContext：<br>它是从类的根路径下加载配置文件 推荐使用这种<br>FileSystemXmlApplicationContext：<br>它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。<br>AnnotationConfigApplicationContext:<br>当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p>
</blockquote>
<h2 id="4-IOC-中-bean-标签和管理对象细节"><a href="#4-IOC-中-bean-标签和管理对象细节" class="headerlink" title="4.IOC 中 bean 标签和管理对象细节"></a><center>4.IOC 中 bean 标签和管理对象细节</center></h2><h3 id="4-1-bean标签"><a href="#4-1-bean标签" class="headerlink" title="4.1.bean标签"></a>4.1.bean标签</h3><blockquote>
<p>作用：<br>用于配置对象让 spring 来创建的。<br>默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。<br>属性：<br>id： 给对象在容器中提供一个唯一标识。用于获取对象。<br>class： 指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。<br>scope： 指定对象的作用范围。</p>
<ul>
<li>singleton :默认值，单例的.</li>
<li>prototype :多例的.</li>
<li>request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中.</li>
<li>session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.</li>
<li>global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session.</li>
</ul>
<p>init-method： 指定类中的初始化方法名称。<br>destroy-method： 指定类中销毁方法名称。</p>
</blockquote>
<h3 id="4-2bean-的作用范围和生命周期"><a href="#4-2bean-的作用范围和生命周期" class="headerlink" title="4.2bean 的作用范围和生命周期"></a>4.2bean 的作用范围和生命周期</h3><blockquote>
<p>单例对象： scope=”singleton”<br>    一个应用只有一个对象的实例。它的作用范围就是整个引用。<br>    生命周期：<br>        对象出生：当应用加载，创建容器时，对象就被创建了。<br>        对象活着：只要容器在，对象一直活着。<br>        对象死亡：当应用卸载，销毁容器时，对象就被销毁了。<br>多例对象： scope=”prototype”<br>    每次访问对象时，都会重新创建对象实例。<br>    生命周期：<br>        对象出生：当使用对象时，创建新的对象实例。<br>        对象活着：只要对象在使用中，就一直活着。<br>        对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。</p>
</blockquote>
<h3 id="4-3实例化-Bean-的三种方式"><a href="#4-3实例化-Bean-的三种方式" class="headerlink" title="4.3实例化 Bean 的三种方式"></a>4.3实例化 Bean 的三种方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种方式：使用默认无参构造函数</span><br><span class="line">&lt;!--在默认情况下：</span><br><span class="line">它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.syx.service.impl.AccountServiceImpl&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第二种方式： spring 管理静态工厂-使用静态工厂的方法创建对象</span><br><span class="line">&#x2F;**</span><br><span class="line">* 模拟一个静态工厂，创建业务层实现类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class StaticFactory &#123;</span><br><span class="line">public static IAccountService createAccountService()&#123;</span><br><span class="line">		return new AccountServiceImpl();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 此种方式是:</span><br><span class="line">使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器</span><br><span class="line">id 属性：指定 bean 的 id，用于从容器中获取</span><br><span class="line">class 属性：指定静态工厂的全限定类名</span><br><span class="line">factory-method 属性：指定生产对象的静态方法</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot;</span><br><span class="line">class&#x3D;&quot;com.syx.factory.StaticFactory&quot;</span><br><span class="line">factory-method&#x3D;&quot;createAccountService&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第三种方式： spring 管理实例工厂-使用实例工厂的方法创建对象</span><br><span class="line">&#x2F;**</span><br><span class="line">* 模拟一个实例工厂，创建业务层实现类</span><br><span class="line">* 此工厂创建对象，必须现有工厂实例对象，再调用方法</span><br><span class="line">*&#x2F;</span><br><span class="line">public class InstanceFactory &#123;</span><br><span class="line">public IAccountService createAccountService()&#123;</span><br><span class="line">return new AccountServiceImpl();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 此种方式是：</span><br><span class="line">先把工厂的创建交给 spring 来管理。</span><br><span class="line">然后在使用工厂的 bean 来调用里面的方法</span><br><span class="line">factory-bean 属性：用于指定实例工厂 bean 的 id。</span><br><span class="line">factory-method 属性：用于指定实例工厂中创建对象的方法。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;instancFactory&quot; class&#x3D;&quot;com.syx.factory.InstanceFactory&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot;</span><br><span class="line">factory-bean&#x3D;&quot;instancFactory&quot;</span><br><span class="line">factory-method&#x3D;&quot;createAccountService&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-4spring-的依赖注入"><a href="#4-4spring-的依赖注入" class="headerlink" title="4.4spring 的依赖注入"></a>4.4spring 的依赖注入</h3><h4 id="4-4-1-依赖注入的概念"><a href="#4-4-1-依赖注入的概念" class="headerlink" title="4.4.1.依赖注入的概念"></a>4.4.1.依赖注入的概念</h4><blockquote>
<p>依赖注入： Dependency Injection。 它是 spring 框架核心 ioc 的具体实现。<br>我们的程序在编写时， 通过控制反转， 把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。<br>ioc 解耦只是降低他们的依赖关系，但不会消除。 例如：我们的业务层仍会调用持久层的方法。<br>那这种业务层和持久层的依赖关系， 在使用 spring 之后， 就让 spring 来维护了。<br>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p>
</blockquote>
<h4 id="4-4-2-构造函数注入"><a href="#4-4-2-构造函数注入" class="headerlink" title="4.4.2.构造函数注入"></a>4.4.2.构造函数注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String sex;</span><br><span class="line">    private Date   birthday;</span><br><span class="line">    public AccountDaoImpl(String name,String sex,Date birthday)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">        this.birthday &#x3D; birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        System.out.println(name+&quot;,&quot;+sex+&quot;，&quot;+birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用构造函数的方式，给 service 中的属性传值</span><br><span class="line">要求：</span><br><span class="line">类中需要提供一个对应参数列表的构造函数。</span><br><span class="line">涉及的标签：</span><br><span class="line">constructor-arg</span><br><span class="line">属性：</span><br><span class="line">index:指定参数在构造函数参数列表的索引位置</span><br><span class="line">type:name:指定参数在构造函数中的名称 用这个找给谁赋值</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;上面三个都是找给谁赋值，下面两个指的是赋什么值的&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">value:它能赋的值是基本数据类型和 String 类型</span><br><span class="line">ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;birthday&quot; ref&#x3D;&quot;now&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;now&quot; class&#x3D;&quot;java.util.Date&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-3-set-方法注入"><a href="#4-4-3-set-方法注入" class="headerlink" title="4.4.3.set 方法注入"></a>4.4.3.set 方法注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line">private String name;</span><br><span class="line">private Integer age;</span><br><span class="line">private Date birthday;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(Integer age) &#123;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">public void setBirthday(Date birthday) &#123;</span><br><span class="line">this.birthday &#x3D; birthday;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void saveAccount() &#123;</span><br><span class="line">System.out.println(name+&quot;,&quot;+age+&quot;,&quot;+birthday);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式</span><br><span class="line">涉及的标签：</span><br><span class="line">属性：</span><br><span class="line">name：找的是类中 set 方法后面的部分</span><br><span class="line">ref：给属性赋值是其他 bean 类型的</span><br><span class="line">value：给属性赋值是基本数据类型和 string 类型的</span><br><span class="line">实际开发中，此种方式用的较多。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;test&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;21&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;birthday&quot; ref&#x3D;&quot;now&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;now&quot; class&#x3D;&quot;java.util.Date&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-4-注入集合属性"><a href="#4-4-4-注入集合属性" class="headerlink" title="4.4.4.注入集合属性"></a>4.4.4.注入集合属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">    private String[] myStrs;</span><br><span class="line">    private List&lt;String&gt; myList;</span><br><span class="line">    private Set&lt;String&gt; mySet;</span><br><span class="line">    private Map&lt;String,String&gt; myMap;</span><br><span class="line">    private Properties myProps;</span><br><span class="line"></span><br><span class="line">    public void setMyStrs(String[] myStrs) &#123;</span><br><span class="line">        this.myStrs &#x3D; myStrs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyList(List&lt;String&gt; myList) &#123;</span><br><span class="line">        this.myList &#x3D; myList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMySet(Set&lt;String&gt; mySet) &#123;</span><br><span class="line">        this.mySet &#x3D; mySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyMap(Map&lt;String, String&gt; myMap) &#123;</span><br><span class="line">        this.myMap &#x3D; myMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyProps(Properties myProps) &#123;</span><br><span class="line">        this.myProps &#x3D; myProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        System.out.println(Arrays.toString(myStrs));</span><br><span class="line">        System.out.println(myList);</span><br><span class="line">        System.out.println(mySet);</span><br><span class="line">        System.out.println(myMap);</span><br><span class="line">        System.out.println(myProps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">        &lt;!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中</span><br><span class="line">        id 属性：对象的唯一标识。</span><br><span class="line">        class 属性：指定要创建对象的全限定类名</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;!--配置Service--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.syx.service.Impl.AccountServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 注入集合数据</span><br><span class="line">    List 结构的：array,list,set</span><br><span class="line">    Map 结构的map,entry,props,prop</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--配置Dao--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;accountDao&quot; class&#x3D;&quot;com.syx.dao.Impl.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;myStrs&quot;&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;value&gt;AAA&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;value&gt;BBB&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;value&gt;CCC&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;set&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;myList&quot;&gt;</span><br><span class="line">           &lt;array&gt;</span><br><span class="line">               &lt;value&gt;AAA&lt;&#x2F;value&gt;</span><br><span class="line">               &lt;value&gt;BBB&lt;&#x2F;value&gt;</span><br><span class="line">               &lt;value&gt;CCC&lt;&#x2F;value&gt;</span><br><span class="line">           &lt;&#x2F;array&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;mySet&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;AAA&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;value&gt;BBB&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;value&gt;CCC&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;myMap&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;testA&quot;&gt;aaa&lt;&#x2F;prop&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;testB&quot;&gt;bbb&lt;&#x2F;prop&gt;</span><br><span class="line">            &lt;&#x2F;props&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;myProps&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;testA&quot; value&#x3D;&quot;aaa&quot;&gt;&lt;&#x2F;entry&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;testB&quot;&gt;</span><br><span class="line">                &lt;value&gt;bbb&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;&#x2F;entry&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记（四）</title>
    <url>/2020/03/30/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Mybatis学习笔记（四）"><a href="#Mybatis学习笔记（四）" class="headerlink" title="Mybatis学习笔记（四）"></a><center>Mybatis学习笔记（四）</center></h1><h2 id="1-Mybatis的动态语句"><a href="#1-Mybatis的动态语句" class="headerlink" title="1.Mybatis的动态语句"></a>1.Mybatis的动态语句</h2><h3 id="1-1动态-SQL-之if标签"><a href="#1-1动态-SQL-之if标签" class="headerlink" title="1.1动态 SQL 之if标签"></a>1.1动态 SQL 之if标签</h3><p>持久层 Dao 接口 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *根据传入参数条件，有可能有用户名、性别、地址，也可能全有</span><br><span class="line"> *&#x2F;</span><br><span class="line">List&lt;User&gt; findUserByCondition(User user);</span><br></pre></td></tr></table></figure>

<p>持久层 Dao 映射配置  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--根据传入参数查询--&gt;</span><br><span class="line">   &lt;select id&#x3D;&quot;findUserByCondition&quot; resultType&#x3D;&quot;user&quot; parameterType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">       select * from user and 1 &#x3D; 1</span><br><span class="line">       &lt;if test&#x3D;&quot;username!&#x3D;null&quot;&gt;</span><br><span class="line">           and username &#x3D; #&#123;username&#125;</span><br><span class="line">       &lt;&#x2F;if&gt;</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>测试  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public  void findUserByCondition()&#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setUsername(&quot;老王&quot;);</span><br><span class="line">        List&lt;User&gt; userList &#x3D; userDao.findUserByCondition(user);</span><br><span class="line">        for (User user1 : userList) &#123;</span><br><span class="line">            System.out.println(user1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2动态-SQL-之where标签"><a href="#1-2动态-SQL-之where标签" class="headerlink" title="1.2动态 SQL 之where标签"></a>1.2动态 SQL 之where标签</h3><p>持久层 Dao 映射配置  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--根据传入参数查询--&gt;</span><br><span class="line">   &lt;select id&#x3D;&quot;findUserByCondition&quot; resultType&#x3D;&quot;user&quot; parameterType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">       select * from user</span><br><span class="line">       &lt;where&gt;</span><br><span class="line">       &lt;if test&#x3D;&quot;username!&#x3D;null&quot;&gt;</span><br><span class="line">           and username &#x3D; #&#123;username&#125;</span><br><span class="line">       &lt;&#x2F;if&gt;</span><br><span class="line">       &lt;if test&#x3D;&quot;sex!&#x3D;null&quot;&gt;</span><br><span class="line">           and sex &#x3D; #&#123;sex&#125;</span><br><span class="line">       &lt;&#x2F;if&gt;</span><br><span class="line">       &lt;&#x2F;where&gt;</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-3动态标签之foreach标签"><a href="#1-3动态标签之foreach标签" class="headerlink" title="1.3动态标签之foreach标签"></a>1.3动态标签之foreach标签</h3><p>QueryVo对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class QueryVo &#123;</span><br><span class="line">    private User user;</span><br><span class="line">    private List&lt;Integer&gt; ids;</span><br><span class="line"></span><br><span class="line">    public User getUser() &#123;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUser(User user) &#123;</span><br><span class="line">        this.user &#x3D; user;</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; getIds() &#123;</span><br><span class="line">        return ids;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setIds(List&lt;Integer&gt; ids) &#123;</span><br><span class="line">        this.ids &#x3D; ids;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>持久层 Dao 接口 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *根据 QueryVo提供的Ids查询用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">List&lt;User&gt; findUserInIds(QueryVo queryVo);</span><br></pre></td></tr></table></figure>

<p>持久层 Dao 映射配置  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--根据Ids查询--&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findUserInIds&quot; parameterType&#x3D;&quot;queryvo&quot; resultType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;if test&#x3D;&quot;ids!&#x3D;null and ids.size()&gt;0&quot;&gt;</span><br><span class="line">            &lt;foreach collection&#x3D;&quot;ids&quot; open&#x3D;&quot;id in (&quot; close&#x3D;&quot;)&quot; item&#x3D;&quot;id&quot; separator&#x3D;&quot;,&quot;&gt;</span><br><span class="line">                #&#123;id&#125;</span><br><span class="line">            &lt;&#x2F;foreach&gt;</span><br><span class="line">        &lt;&#x2F;if&gt;</span><br><span class="line">    &lt;&#x2F;where&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void findUserInIds()&#123;</span><br><span class="line">        QueryVo queryVo &#x3D; new QueryVo();</span><br><span class="line">        List&lt;Integer&gt; ids &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        ids.add(41);</span><br><span class="line">        ids.add(42);</span><br><span class="line">        ids.add(43);</span><br><span class="line">        queryVo.setIds(ids);</span><br><span class="line">        List&lt;User&gt; userList &#x3D; userDao.findUserInIds(queryVo);</span><br><span class="line">        for (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Mybatis-中简化编写的-SQL-片段"><a href="#2-Mybatis-中简化编写的-SQL-片段" class="headerlink" title="2.Mybatis 中简化编写的 SQL 片段"></a>2.Mybatis 中简化编写的 SQL 片段</h2><blockquote>
<p>Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。  </p>
</blockquote>
<p>定义代码片段  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 抽取重复的语句代码片段 --&gt;</span><br><span class="line">&lt;sql id&#x3D;&quot;defaultSql&quot;&gt;</span><br><span class="line">select * from user</span><br><span class="line">&lt;&#x2F;sql&gt;</span><br></pre></td></tr></table></figure>

<p>引用代码片段  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置查询所有操作 --&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">&lt;include refid&#x3D;&quot;defaultSql&quot;&gt;&lt;&#x2F;include&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-Mybatis-多表查询之一对多"><a href="#3-Mybatis-多表查询之一对多" class="headerlink" title="3.Mybatis 多表查询之一对多"></a>3.Mybatis 多表查询之一对多</h2><h3 id="3-1-一对一查询-多对一"><a href="#3-1-一对一查询-多对一" class="headerlink" title="3.1 一对一查询(多对一)"></a>3.1 一对一查询(多对一)</h3><blockquote>
<p>使用 resultMap，定义专门的 resultMap 用于映射一对一查询结果。<br>通过面向对象的(has a)关系可以得知，我们可以在 Account 类中加入一个 User 类的对象来代表这个账户<br>是哪个用户的。  </p>
</blockquote>
<p>Account 类  ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private Integer uid;</span><br><span class="line">    private double money;</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getUid() &#123;</span><br><span class="line">        return uid;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUid(Integer uid) &#123;</span><br><span class="line">        this.uid &#x3D; uid;</span><br><span class="line">    &#125;</span><br><span class="line">    public double getMoney() &#123;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMoney(double money) &#123;</span><br><span class="line">        this.money &#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line">    public User getUser() &#123;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUser(User user) &#123;</span><br><span class="line">        this.user &#x3D; user;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Account&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, uid&#x3D;&quot; + uid +</span><br><span class="line">                &quot;, money&#x3D;&quot; + money +</span><br><span class="line">                &quot;, user&#x3D;&quot; + user +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>AccountDao 接口中的方法 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查询所有</span><br><span class="line"> *&#x2F;</span><br><span class="line">List&lt;Account&gt; findAll();</span><br></pre></td></tr></table></figure>

<p>AccountDao.xml 文件 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.syx.dao.IAccountDao&quot;&gt;</span><br><span class="line">    &lt;!--定义封装account和user的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;accountUserMao&quot; type&#x3D;&quot;account&quot;&gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;aid&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;uid&quot; column&#x3D;&quot;uid&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;money&quot; column&#x3D;&quot;money&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--一对一关系映射，配置User的内容--&gt;</span><br><span class="line">        &lt;association property&#x3D;&quot;user&quot; column&#x3D;&quot;uid&quot; javaType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">            &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;birthday&quot; column&#x3D;&quot;birthday&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;sex&quot; column&#x3D;&quot;sex&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;association&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;accountUserMao&quot;&gt;</span><br><span class="line">    SELECT u.*,a.id as aid,a.uid,a.money FROM USER u,account a WHERE u.id &#x3D; a.UID</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>测试方法 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">  public void findAll()&#123;</span><br><span class="line">      List&lt;Account&gt; accountList &#x3D; accountDao.findAll();</span><br><span class="line">      for (Account account : accountList) &#123;</span><br><span class="line">          System.out.println(account);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2一对多查询"><a href="#3-2一对多查询" class="headerlink" title="3.2一对多查询"></a>3.2一对多查询</h3><p>编写 SQL 语句 :</p>
<blockquote>
<p>SELECT * FROM USER u LEFT OUTER JOIN account a ON u.id = a.uid </p>
</blockquote>
<p>User 类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private  Integer id;</span><br><span class="line">    private  String username;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private  String sex;</span><br><span class="line">    private  String address;</span><br><span class="line">    private List&lt;Account&gt; accounts;</span><br><span class="line">    &#x2F;&#x2F;一对多关系映射，主表实体应该包含从表实体的集合引用</span><br><span class="line">    public List&lt;Account&gt; getAccounts() &#123;</span><br><span class="line">        return accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class="line">        this.accounts &#x3D; accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday &#x3D; birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, birthday&#x3D;&quot; + birthday +</span><br><span class="line">                &quot;, sex&#x3D;&#39;&quot; + sex + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, address&#x3D;&#39;&quot; + address + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户持久层 Dao 映射文件配置 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.syx.dao.IUserDao&quot;&gt;</span><br><span class="line">    &lt;!--定义user的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;userAccountMap&quot; type&#x3D;&quot;user&quot;&gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;birthday&quot; column&#x3D;&quot;birthday&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;sex&quot; column&#x3D;&quot;sex&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot;&#x2F;&gt;</span><br><span class="line">        &lt;collection property&#x3D;&quot;accounts&quot; ofType&#x3D;&quot;account&quot;&gt;</span><br><span class="line">            &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;aid&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;uid&quot; column&#x3D;&quot;uid&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;money&quot; column&#x3D;&quot;money&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;collection&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line">    &lt;!-- 配置查询所有--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;userAccountMap&quot;&gt;</span><br><span class="line">       SELECT * FROM USER u LEFT OUTER JOIN account a ON u.id &#x3D; a.uid</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MybatisTest &#123;</span><br><span class="line">    private InputStream in ;</span><br><span class="line">    private SqlSessionFactory factory;</span><br><span class="line">    private SqlSession session;</span><br><span class="line">    private IUserDao userDao;</span><br><span class="line">    @Before</span><br><span class="line">    public void init() throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1.读取配置文件</span><br><span class="line">       in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.创建构建者对象</span><br><span class="line">        SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">        &#x2F;&#x2F; 3.创建SqlSession工厂对象</span><br><span class="line">         factory &#x3D; builder.build(in);</span><br><span class="line">        &#x2F;&#x2F;4.创建SqlSession对向</span><br><span class="line">        session &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;5.创建Dao代理对象</span><br><span class="line">        userDao &#x3D; session.getMapper(IUserDao.class);</span><br><span class="line">        &#125;</span><br><span class="line">        @After</span><br><span class="line">        public void destroy() throws Exception&#123;</span><br><span class="line">            session.commit();</span><br><span class="line">            &#x2F;&#x2F;7.释放资源</span><br><span class="line">            session.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        @Test</span><br><span class="line">        public void findAll()&#123;</span><br><span class="line">            List&lt;User&gt; userList &#x3D; userDao.findAll();</span><br><span class="line">            for (User user : userList) &#123;</span><br><span class="line">                System.out.println(&quot;------------每个用户信息&quot;);</span><br><span class="line">                System.out.println(user);</span><br><span class="line">                System.out.println(user.getAccounts());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Mybatis-多表查询之多对多"><a href="#4-Mybatis-多表查询之多对多" class="headerlink" title="4.Mybatis 多表查询之多对多"></a>4.Mybatis 多表查询之多对多</h3><h4 id="4-1实现-Role-到-User-多对多"><a href="#4-1实现-Role-到-User-多对多" class="headerlink" title="4.1实现 Role 到 User 多对多"></a>4.1实现 Role 到 User 多对多</h4><p>业务要求及实现 SQL  </p>
<blockquote>
<p>需求：<br>实现查询所有对象并且加载它所分配的用户信息。<br>分析：<br>查询角色我们需要用到Role表，但角色分配的用户的信息我们并不能直接找到用户信息，而是要通过中<br>间表(USER_ROLE 表)才能关联到用户信息。<br>下面是实现的 SQL 语句：<br>SELECT<br>r.*,u.id uid,<br>u.username username,<br>u.birthday birthday,<br>u.sex sex,<br>u.address address<br>FROM<br>ROLE r<br>INNER JOIN<br>USER_ROLE ur<br>ON ( r.id = ur.rid)<br>INNER JOIN<br>USER u<br>ON (ur.uid = u.id);  </p>
</blockquote>
<p>编写角色实体类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Role &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String  rolename;</span><br><span class="line">    private String roledesc;</span><br><span class="line">    private List&lt;User&gt; users;</span><br><span class="line"></span><br><span class="line">    public List&lt;User&gt; getUsers() &#123;</span><br><span class="line">        return users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">        this.users &#x3D; users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getRolename() &#123;</span><br><span class="line">        return rolename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRolename(String rolename) &#123;</span><br><span class="line">        this.rolename &#x3D; rolename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getRoledesc() &#123;</span><br><span class="line">        return roledesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoledesc(String roledesc) &#123;</span><br><span class="line">        this.roledesc &#x3D; roledesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Role&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, rolename&#x3D;&#39;&quot; + rolename + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, roledesc&#x3D;&#39;&quot; + roledesc + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写 Role 持久层接口 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IRoleDao &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询所有角色</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;Role&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写映射文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.syx.dao.IRoleDao&quot;&gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;RoleMap&quot; type&#x3D;&quot;role&quot;&gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;rid&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;rolename&quot; column&#x3D;&quot;role_name&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;roledesc&quot; column&#x3D;&quot;role_desc&quot;&#x2F;&gt;</span><br><span class="line">        &lt;collection property&#x3D;&quot;users&quot; ofType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">            &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;birthday&quot; column&#x3D;&quot;birthday&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;sex&quot; column&#x3D;&quot;sex&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;collection&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;RoleMap&quot;&gt;</span><br><span class="line">        SELECT u.*,r.id AS rid,r.role_name,r.role_desc FROM role r</span><br><span class="line">        LEFT OUTER JOIN user_role ur ON r.id &#x3D; ur.rid</span><br><span class="line">        LEFT OUTER JOIN USER u ON u.id &#x3D; ur.uid</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>编写测试类 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line"> public void findAll()&#123;</span><br><span class="line">     List&lt;Role&gt; roleList &#x3D; roleDao.findAll();</span><br><span class="line">     for (Role role : roleList) &#123;</span><br><span class="line">         System.out.println(role);</span><br><span class="line">         System.out.println(role.getUsers());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2实现-User-到-Role-的多对多"><a href="#4-2实现-User-到-Role-的多对多" class="headerlink" title="4.2实现 User 到 Role 的多对多"></a>4.2实现 User 到 Role 的多对多</h3><p>User 到 Role 的多对多  </p>
<blockquote>
<p>从 User 出发，我们也可以发现一个用户可以具有多个角色，这样用户到角色的关系也还是一对多关系。这样<br>我们就可以认为 User 与 Role 的多对多关系，可以被拆解成两个一对多关系来实现。  </p>
</blockquote>
<p>SQL </p>
<blockquote>
<p>SELECT u.*,r.id AS rid,r.role_name,r.role_desc FROM USER u<br>LEFT OUTER JOIN user_role ur ON u.id = ur.uid<br> LEFT OUTER JOIN role r ON r.id = ur.rid</p>
</blockquote>
<p>编写角色实体类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private  Integer id;</span><br><span class="line">    private  String username;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private  String sex;</span><br><span class="line">    private  String address;</span><br><span class="line">    &#x2F;&#x2F;一对多关系映射，主表实体应该包含从表实体的集合引用</span><br><span class="line">    private List&lt;Account&gt; accounts;</span><br><span class="line">    private List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line">    public List&lt;Role&gt; getRoles() &#123;</span><br><span class="line">        return roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoles(List&lt;Role&gt; roles) &#123;</span><br><span class="line">        this.roles &#x3D; roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Account&gt; getAccounts() &#123;</span><br><span class="line">        return accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class="line">        this.accounts &#x3D; accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday &#x3D; birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, birthday&#x3D;&quot; + birthday +</span><br><span class="line">                &quot;, sex&#x3D;&#39;&quot; + sex + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, address&#x3D;&#39;&quot; + address + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写映射文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.syx.dao.IUserDao&quot;&gt;</span><br><span class="line">    &lt;!--定义user的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;userRoleMap&quot; type&#x3D;&quot;user&quot;&gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;birthday&quot; column&#x3D;&quot;birthday&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;sex&quot; column&#x3D;&quot;sex&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot;&#x2F;&gt;</span><br><span class="line">        &lt;collection property&#x3D;&quot;roles&quot; ofType&#x3D;&quot;role&quot;&gt;</span><br><span class="line">            &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;rid&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;rolename&quot; column&#x3D;&quot;role_name&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;roledesc&quot; column&#x3D;&quot;role_desc&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;collection&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line">    &lt;!-- 配置查询所有--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;userRoleMap&quot;&gt;</span><br><span class="line">      SELECT u.*,r.id AS rid,r.role_name,r.role_desc FROM USER u</span><br><span class="line">      LEFT OUTER JOIN user_role ur ON u.id &#x3D; ur.uid</span><br><span class="line">      LEFT OUTER JOIN role r ON r.id &#x3D; ur.rid</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>编写测试类 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MybatisTest &#123;</span><br><span class="line">    private InputStream in ;</span><br><span class="line">    private SqlSessionFactory factory;</span><br><span class="line">    private SqlSession session;</span><br><span class="line">    private IUserDao userDao;</span><br><span class="line">    @Before</span><br><span class="line">    public void init() throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1.读取配置文件</span><br><span class="line">       in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.创建构建者对象</span><br><span class="line">        SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">        &#x2F;&#x2F; 3.创建SqlSession工厂对象</span><br><span class="line">         factory &#x3D; builder.build(in);</span><br><span class="line">        &#x2F;&#x2F;4.创建SqlSession对向</span><br><span class="line">        session &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;5.创建Dao代理对象</span><br><span class="line">        userDao &#x3D; session.getMapper(IUserDao.class);</span><br><span class="line">        &#125;</span><br><span class="line">        @After</span><br><span class="line">        public void destroy() throws Exception&#123;</span><br><span class="line">            session.commit();</span><br><span class="line">            &#x2F;&#x2F;7.释放资源</span><br><span class="line">            session.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        @Test</span><br><span class="line">        public void findAll()&#123;</span><br><span class="line">            List&lt;User&gt; userList &#x3D; userDao.findAll();</span><br><span class="line">            for (User user : userList) &#123;</span><br><span class="line">                System.out.println(&quot;------------每个用户信息&quot;);</span><br><span class="line">                System.out.println(user);</span><br><span class="line">                System.out.println(user.getRoles());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
</search>
